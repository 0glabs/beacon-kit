// Code generated by fastssz. DO NOT EDIT.
// Hash: d4a5872d1cfcf523ceb53e3263fa4907fd6747086a830030c14c8f135a683a04
package types

import (
	ssz "github.com/prysmaticlabs/fastssz"
)

// MarshalSSZ ssz marshals the CometBFTHeader object
func (c *CometBFTHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CometBFTHeader object to a target array
func (c *CometBFTHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(380)

	// Field (0) 'Version'
	if c.Version == nil {
		c.Version = new(Consensus)
	}
	if dst, err = c.Version.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'ChainID'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.ChainID)

	// Field (2) 'Height'
	dst = ssz.MarshalUint64(dst, c.Height)

	// Field (3) 'Time'
	dst = ssz.MarshalUint64(dst, c.Time)

	// Field (4) 'LastBlockID'
	if c.LastBlockID == nil {
		c.LastBlockID = new(BlockID)
	}
	if dst, err = c.LastBlockID.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'LastCommitHash'
	dst = append(dst, c.LastCommitHash[:]...)

	// Field (6) 'DataHash'
	dst = append(dst, c.DataHash[:]...)

	// Field (7) 'ValidatorsHash'
	dst = append(dst, c.ValidatorsHash[:]...)

	// Field (8) 'NextValidatorsHash'
	dst = append(dst, c.NextValidatorsHash[:]...)

	// Field (9) 'ConsensusHash'
	dst = append(dst, c.ConsensusHash[:]...)

	// Field (10) 'AppHash'
	dst = append(dst, c.AppHash[:]...)

	// Field (11) 'LastResultsHash'
	dst = append(dst, c.LastResultsHash[:]...)

	// Field (12) 'EvidenceHash'
	dst = append(dst, c.EvidenceHash[:]...)

	// Field (13) 'ProposerAddress'
	dst = append(dst, c.ProposerAddress[:]...)

	// Field (1) 'ChainID'
	if size := len(c.ChainID); size > 50 {
		err = ssz.ErrBytesLengthFn("--.ChainID", size, 50)
		return
	}
	dst = append(dst, c.ChainID...)

	return
}

// UnmarshalSSZ ssz unmarshals the CometBFTHeader object
func (c *CometBFTHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 380 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Version'
	if c.Version == nil {
		c.Version = new(Consensus)
	}
	if err = c.Version.UnmarshalSSZ(buf[0:16]); err != nil {
		return err
	}

	// Offset (1) 'ChainID'
	if o1 = ssz.ReadOffset(buf[16:20]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 380 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'Height'
	c.Height = ssz.UnmarshallUint64(buf[20:28])

	// Field (3) 'Time'
	c.Time = ssz.UnmarshallUint64(buf[28:36])

	// Field (4) 'LastBlockID'
	if c.LastBlockID == nil {
		c.LastBlockID = new(BlockID)
	}
	if err = c.LastBlockID.UnmarshalSSZ(buf[36:104]); err != nil {
		return err
	}

	// Field (5) 'LastCommitHash'
	copy(c.LastCommitHash[:], buf[104:136])

	// Field (6) 'DataHash'
	copy(c.DataHash[:], buf[136:168])

	// Field (7) 'ValidatorsHash'
	copy(c.ValidatorsHash[:], buf[168:200])

	// Field (8) 'NextValidatorsHash'
	copy(c.NextValidatorsHash[:], buf[200:232])

	// Field (9) 'ConsensusHash'
	copy(c.ConsensusHash[:], buf[232:264])

	// Field (10) 'AppHash'
	copy(c.AppHash[:], buf[264:296])

	// Field (11) 'LastResultsHash'
	copy(c.LastResultsHash[:], buf[296:328])

	// Field (12) 'EvidenceHash'
	copy(c.EvidenceHash[:], buf[328:360])

	// Field (13) 'ProposerAddress'
	copy(c.ProposerAddress[:], buf[360:380])

	// Field (1) 'ChainID'
	{
		buf = tail[o1:]
		if len(buf) > 50 {
			return ssz.ErrBytesLength
		}
		if cap(c.ChainID) == 0 {
			c.ChainID = make([]byte, 0, len(buf))
		}
		c.ChainID = append(c.ChainID, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CometBFTHeader object
func (c *CometBFTHeader) SizeSSZ() (size int) {
	size = 380

	// Field (1) 'ChainID'
	size += len(c.ChainID)

	return
}

// HashTreeRoot ssz hashes the CometBFTHeader object
func (c *CometBFTHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CometBFTHeader object with a hasher
func (c *CometBFTHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Version'
	if err = c.Version.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'ChainID'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.ChainID))
		if byteLen > 50 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(c.ChainID)
		if ssz.EnableVectorizedHTR {
			hh.MerkleizeWithMixinVectorizedHTR(elemIndx, byteLen, (50+31)/32)
		} else {
			hh.MerkleizeWithMixin(elemIndx, byteLen, (50+31)/32)
		}
	}

	// Field (2) 'Height'
	hh.PutUint64(c.Height)

	// Field (3) 'Time'
	hh.PutUint64(c.Time)

	// Field (4) 'LastBlockID'
	if err = c.LastBlockID.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'LastCommitHash'
	hh.PutBytes(c.LastCommitHash[:])

	// Field (6) 'DataHash'
	hh.PutBytes(c.DataHash[:])

	// Field (7) 'ValidatorsHash'
	hh.PutBytes(c.ValidatorsHash[:])

	// Field (8) 'NextValidatorsHash'
	hh.PutBytes(c.NextValidatorsHash[:])

	// Field (9) 'ConsensusHash'
	hh.PutBytes(c.ConsensusHash[:])

	// Field (10) 'AppHash'
	hh.PutBytes(c.AppHash[:])

	// Field (11) 'LastResultsHash'
	hh.PutBytes(c.LastResultsHash[:])

	// Field (12) 'EvidenceHash'
	hh.PutBytes(c.EvidenceHash[:])

	// Field (13) 'ProposerAddress'
	hh.PutBytes(c.ProposerAddress[:])

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the BlockID object
func (b *BlockID) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockID object to a target array
func (b *BlockID) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	dst = append(dst, b.Hash[:]...)

	// Field (1) 'PartSetHeader'
	if b.PartSetHeader == nil {
		b.PartSetHeader = new(PartSetHeader)
	}
	if dst, err = b.PartSetHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockID object
func (b *BlockID) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 68 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	copy(b.Hash[:], buf[0:32])

	// Field (1) 'PartSetHeader'
	if b.PartSetHeader == nil {
		b.PartSetHeader = new(PartSetHeader)
	}
	if err = b.PartSetHeader.UnmarshalSSZ(buf[32:68]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockID object
func (b *BlockID) SizeSSZ() (size int) {
	size = 68
	return
}

// HashTreeRoot ssz hashes the BlockID object
func (b *BlockID) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockID object with a hasher
func (b *BlockID) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	hh.PutBytes(b.Hash[:])

	// Field (1) 'PartSetHeader'
	if err = b.PartSetHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the PartSetHeader object
func (p *PartSetHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PartSetHeader object to a target array
func (p *PartSetHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	dst = append(dst, p.Hash[:]...)

	// Field (1) 'Total'
	dst = ssz.MarshalUint32(dst, p.Total)

	return
}

// UnmarshalSSZ ssz unmarshals the PartSetHeader object
func (p *PartSetHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 36 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	copy(p.Hash[:], buf[0:32])

	// Field (1) 'Total'
	p.Total = ssz.UnmarshallUint32(buf[32:36])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PartSetHeader object
func (p *PartSetHeader) SizeSSZ() (size int) {
	size = 36
	return
}

// HashTreeRoot ssz hashes the PartSetHeader object
func (p *PartSetHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PartSetHeader object with a hasher
func (p *PartSetHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	hh.PutBytes(p.Hash[:])

	// Field (1) 'Total'
	hh.PutUint32(p.Total)

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the Consensus object
func (c *Consensus) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Consensus object to a target array
func (c *Consensus) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Block'
	dst = ssz.MarshalUint64(dst, c.Block)

	// Field (1) 'App'
	dst = ssz.MarshalUint64(dst, c.App)

	return
}

// UnmarshalSSZ ssz unmarshals the Consensus object
func (c *Consensus) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'Block'
	c.Block = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'App'
	c.App = ssz.UnmarshallUint64(buf[8:16])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Consensus object
func (c *Consensus) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the Consensus object
func (c *Consensus) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Consensus object with a hasher
func (c *Consensus) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	hh.PutUint64(c.Block)

	// Field (1) 'App'
	hh.PutUint64(c.App)

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}
