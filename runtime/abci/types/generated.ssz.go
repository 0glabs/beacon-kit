// Code generated by fastssz. DO NOT EDIT.
// Hash: 4d3da112a8ce80ba73ab5763a69541313a2554014a0d7ab2d85fd2d326467947
package types

import (
	ssz "github.com/prysmaticlabs/fastssz"
)

// MarshalSSZ ssz marshals the CometBFTHeader object
func (c *CometBFTHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CometBFTHeader object to a target array
func (c *CometBFTHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Version'
	if c.Version == nil {
		c.Version = new(Consensus)
	}
	if dst, err = c.Version.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'ChainID'
	if size := len(c.ChainID); size != 50 {
		err = ssz.ErrBytesLengthFn("--.ChainID", size, 50)
		return
	}
	dst = append(dst, c.ChainID...)

	// Field (2) 'Height'
	dst = ssz.MarshalUint64(dst, c.Height)

	// Field (3) 'Time'
	dst = ssz.MarshalUint64(dst, c.Time)

	// Field (4) 'LastBlockID'
	if c.LastBlockID == nil {
		c.LastBlockID = new(BlockID)
	}
	if dst, err = c.LastBlockID.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'LastCommitHash'
	dst = append(dst, c.LastCommitHash[:]...)

	// Field (6) 'DataHash'
	dst = append(dst, c.DataHash[:]...)

	// Field (7) 'ValidatorsHash'
	dst = append(dst, c.ValidatorsHash[:]...)

	// Field (8) 'NextValidatorsHash'
	dst = append(dst, c.NextValidatorsHash[:]...)

	// Field (9) 'ConsensusHash'
	dst = append(dst, c.ConsensusHash[:]...)

	// Field (10) 'AppHash'
	dst = append(dst, c.AppHash[:]...)

	// Field (11) 'LastResultsHash'
	dst = append(dst, c.LastResultsHash[:]...)

	// Field (12) 'EvidenceHash'
	dst = append(dst, c.EvidenceHash[:]...)

	// Field (13) 'ProposerAddr'
	dst = append(dst, c.ProposerAddr[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the CometBFTHeader object
func (c *CometBFTHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 426 {
		return ssz.ErrSize
	}

	// Field (0) 'Version'
	if c.Version == nil {
		c.Version = new(Consensus)
	}
	if err = c.Version.UnmarshalSSZ(buf[0:16]); err != nil {
		return err
	}

	// Field (1) 'ChainID'
	if cap(c.ChainID) == 0 {
		c.ChainID = make([]byte, 0, len(buf[16:66]))
	}
	c.ChainID = append(c.ChainID, buf[16:66]...)

	// Field (2) 'Height'
	c.Height = ssz.UnmarshallUint64(buf[66:74])

	// Field (3) 'Time'
	c.Time = ssz.UnmarshallUint64(buf[74:82])

	// Field (4) 'LastBlockID'
	if c.LastBlockID == nil {
		c.LastBlockID = new(BlockID)
	}
	if err = c.LastBlockID.UnmarshalSSZ(buf[82:150]); err != nil {
		return err
	}

	// Field (5) 'LastCommitHash'
	copy(c.LastCommitHash[:], buf[150:182])

	// Field (6) 'DataHash'
	copy(c.DataHash[:], buf[182:214])

	// Field (7) 'ValidatorsHash'
	copy(c.ValidatorsHash[:], buf[214:246])

	// Field (8) 'NextValidatorsHash'
	copy(c.NextValidatorsHash[:], buf[246:278])

	// Field (9) 'ConsensusHash'
	copy(c.ConsensusHash[:], buf[278:310])

	// Field (10) 'AppHash'
	copy(c.AppHash[:], buf[310:342])

	// Field (11) 'LastResultsHash'
	copy(c.LastResultsHash[:], buf[342:374])

	// Field (12) 'EvidenceHash'
	copy(c.EvidenceHash[:], buf[374:406])

	// Field (13) 'ProposerAddr'
	copy(c.ProposerAddr[:], buf[406:426])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CometBFTHeader object
func (c *CometBFTHeader) SizeSSZ() (size int) {
	size = 426
	return
}

// HashTreeRoot ssz hashes the CometBFTHeader object
func (c *CometBFTHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CometBFTHeader object with a hasher
func (c *CometBFTHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Version'
	if err = c.Version.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'ChainID'
	if size := len(c.ChainID); size != 50 {
		err = ssz.ErrBytesLengthFn("--.ChainID", size, 50)
		return
	}
	hh.PutBytes(c.ChainID)

	// Field (2) 'Height'
	hh.PutUint64(c.Height)

	// Field (3) 'Time'
	hh.PutUint64(c.Time)

	// Field (4) 'LastBlockID'
	if err = c.LastBlockID.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'LastCommitHash'
	hh.PutBytes(c.LastCommitHash[:])

	// Field (6) 'DataHash'
	hh.PutBytes(c.DataHash[:])

	// Field (7) 'ValidatorsHash'
	hh.PutBytes(c.ValidatorsHash[:])

	// Field (8) 'NextValidatorsHash'
	hh.PutBytes(c.NextValidatorsHash[:])

	// Field (9) 'ConsensusHash'
	hh.PutBytes(c.ConsensusHash[:])

	// Field (10) 'AppHash'
	hh.PutBytes(c.AppHash[:])

	// Field (11) 'LastResultsHash'
	hh.PutBytes(c.LastResultsHash[:])

	// Field (12) 'EvidenceHash'
	hh.PutBytes(c.EvidenceHash[:])

	// Field (13) 'ProposerAddr'
	hh.PutBytes(c.ProposerAddr[:])

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the BlockID object
func (b *BlockID) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockID object to a target array
func (b *BlockID) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	dst = append(dst, b.Hash[:]...)

	// Field (1) 'PartsHeader'
	if b.PartsHeader == nil {
		b.PartsHeader = new(PartSetHeader)
	}
	if dst, err = b.PartsHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockID object
func (b *BlockID) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 68 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	copy(b.Hash[:], buf[0:32])

	// Field (1) 'PartsHeader'
	if b.PartsHeader == nil {
		b.PartsHeader = new(PartSetHeader)
	}
	if err = b.PartsHeader.UnmarshalSSZ(buf[32:68]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockID object
func (b *BlockID) SizeSSZ() (size int) {
	size = 68
	return
}

// HashTreeRoot ssz hashes the BlockID object
func (b *BlockID) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockID object with a hasher
func (b *BlockID) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	hh.PutBytes(b.Hash[:])

	// Field (1) 'PartsHeader'
	if err = b.PartsHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the PartSetHeader object
func (p *PartSetHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PartSetHeader object to a target array
func (p *PartSetHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	dst = append(dst, p.Hash[:]...)

	// Field (1) 'Total'
	dst = ssz.MarshalUint32(dst, p.Total)

	return
}

// UnmarshalSSZ ssz unmarshals the PartSetHeader object
func (p *PartSetHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 36 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	copy(p.Hash[:], buf[0:32])

	// Field (1) 'Total'
	p.Total = ssz.UnmarshallUint32(buf[32:36])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PartSetHeader object
func (p *PartSetHeader) SizeSSZ() (size int) {
	size = 36
	return
}

// HashTreeRoot ssz hashes the PartSetHeader object
func (p *PartSetHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PartSetHeader object with a hasher
func (p *PartSetHeader) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	hh.PutBytes(p.Hash[:])

	// Field (1) 'Total'
	hh.PutUint32(p.Total)

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}

// MarshalSSZ ssz marshals the Consensus object
func (c *Consensus) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Consensus object to a target array
func (c *Consensus) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Block'
	dst = ssz.MarshalUint64(dst, c.Block)

	// Field (1) 'App'
	dst = ssz.MarshalUint64(dst, c.App)

	return
}

// UnmarshalSSZ ssz unmarshals the Consensus object
func (c *Consensus) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'Block'
	c.Block = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'App'
	c.App = ssz.UnmarshallUint64(buf[8:16])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Consensus object
func (c *Consensus) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the Consensus object
func (c *Consensus) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Consensus object with a hasher
func (c *Consensus) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	hh.PutUint64(c.Block)

	// Field (1) 'App'
	hh.PutUint64(c.App)

	if ssz.EnableVectorizedHTR {
		hh.MerkleizeVectorizedHTR(indx)
	} else {
		hh.Merkleize(indx)
	}
	return
}
