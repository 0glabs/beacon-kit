// Code generated by ogen, DO NOT EDIT.

package beaconnode

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [2]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/eth/v"
			origElem := elem
			if l := len("/eth/v"); len(elem) >= l && elem[0:l] == "/eth/v" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case '1': // Prefix: "1/"
				origElem := elem
				if l := len("1/"); len(elem) >= l && elem[0:l] == "1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "b"
					origElem := elem
					if l := len("b"); len(elem) >= l && elem[0:l] == "b" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "eacon/"
						origElem := elem
						if l := len("eacon/"); len(elem) >= l && elem[0:l] == "eacon/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "bl"
							origElem := elem
							if l := len("bl"); len(elem) >= l && elem[0:l] == "bl" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "inded_blocks"
								origElem := elem
								if l := len("inded_blocks"); len(elem) >= l && elem[0:l] == "inded_blocks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handlePublishBlindedBlockRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "block_id"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetBlindedBlockRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'o': // Prefix: "o"
								origElem := elem
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "b_sidecars/"
									origElem := elem
									if l := len("b_sidecars/"); len(elem) >= l && elem[0:l] == "b_sidecars/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "block_id"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetBlobSidecarsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 'c': // Prefix: "cks"
									origElem := elem
									if l := len("cks"); len(elem) >= l && elem[0:l] == "cks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handlePublishBlockRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "block_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "attestations"
												origElem := elem
												if l := len("attestations"); len(elem) >= l && elem[0:l] == "attestations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetBlockAttestationsRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											case 'r': // Prefix: "root"
												origElem := elem
												if l := len("root"); len(elem) >= l && elem[0:l] == "root" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetBlockRootRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'd': // Prefix: "deposit_snapshot"
							origElem := elem
							if l := len("deposit_snapshot"); len(elem) >= l && elem[0:l] == "deposit_snapshot" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetDepositSnapshotRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'g': // Prefix: "genesis"
							origElem := elem
							if l := len("genesis"); len(elem) >= l && elem[0:l] == "genesis" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetGenesisRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'h': // Prefix: "headers"
							origElem := elem
							if l := len("headers"); len(elem) >= l && elem[0:l] == "headers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetBlockHeadersRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetBlockHeaderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'l': // Prefix: "light_client/"
							origElem := elem
							if l := len("light_client/"); len(elem) >= l && elem[0:l] == "light_client/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "bootstrap/"
								origElem := elem
								if l := len("bootstrap/"); len(elem) >= l && elem[0:l] == "bootstrap/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_root"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetLightClientBootstrapRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'f': // Prefix: "finality_update"
								origElem := elem
								if l := len("finality_update"); len(elem) >= l && elem[0:l] == "finality_update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetLightClientFinalityUpdateRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'o': // Prefix: "optimistic_update"
								origElem := elem
								if l := len("optimistic_update"); len(elem) >= l && elem[0:l] == "optimistic_update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetLightClientOptimisticUpdateRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 'u': // Prefix: "updates"
								origElem := elem
								if l := len("updates"); len(elem) >= l && elem[0:l] == "updates" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetLightClientUpdatesByRangeRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'p': // Prefix: "pool/"
							origElem := elem
							if l := len("pool/"); len(elem) >= l && elem[0:l] == "pool/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "attest"
								origElem := elem
								if l := len("attest"); len(elem) >= l && elem[0:l] == "attest" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ations"
									origElem := elem
									if l := len("ations"); len(elem) >= l && elem[0:l] == "ations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetPoolAttestationsRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleSubmitPoolAttestationsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

									elem = origElem
								case 'e': // Prefix: "er_slashings"
									origElem := elem
									if l := len("er_slashings"); len(elem) >= l && elem[0:l] == "er_slashings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetPoolAttesterSlashingsRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleSubmitPoolAttesterSlashingsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'b': // Prefix: "bls_to_execution_changes"
								origElem := elem
								if l := len("bls_to_execution_changes"); len(elem) >= l && elem[0:l] == "bls_to_execution_changes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPoolBLSToExecutionChangesRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleSubmitPoolBLSToExecutionChangeRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

								elem = origElem
							case 'p': // Prefix: "proposer_slashings"
								origElem := elem
								if l := len("proposer_slashings"); len(elem) >= l && elem[0:l] == "proposer_slashings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPoolProposerSlashingsRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleSubmitPoolProposerSlashingsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "sync_committees"
								origElem := elem
								if l := len("sync_committees"); len(elem) >= l && elem[0:l] == "sync_committees" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleSubmitPoolSyncCommitteeSignaturesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'v': // Prefix: "voluntary_exits"
								origElem := elem
								if l := len("voluntary_exits"); len(elem) >= l && elem[0:l] == "voluntary_exits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPoolVoluntaryExitsRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleSubmitPoolVoluntaryExitRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "rewards/"
							origElem := elem
							if l := len("rewards/"); len(elem) >= l && elem[0:l] == "rewards/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "attestations/"
								origElem := elem
								if l := len("attestations/"); len(elem) >= l && elem[0:l] == "attestations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "epoch"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGetAttestationsRewardsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'b': // Prefix: "blocks/"
								origElem := elem
								if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetBlockRewardsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "sync_committee/"
								origElem := elem
								if l := len("sync_committee/"); len(elem) >= l && elem[0:l] == "sync_committee/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGetSyncCommitteeRewardsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "states/"
							origElem := elem
							if l := len("states/"); len(elem) >= l && elem[0:l] == "states/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "state_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "committees"
									origElem := elem
									if l := len("committees"); len(elem) >= l && elem[0:l] == "committees" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetEpochCommitteesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 'f': // Prefix: "f"
									origElem := elem
									if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'i': // Prefix: "inality_checkpoints"
										origElem := elem
										if l := len("inality_checkpoints"); len(elem) >= l && elem[0:l] == "inality_checkpoints" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetStateFinalityCheckpointsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									case 'o': // Prefix: "ork"
										origElem := elem
										if l := len("ork"); len(elem) >= l && elem[0:l] == "ork" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetStateForkRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								case 'r': // Prefix: "r"
									origElem := elem
									if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "andao"
										origElem := elem
										if l := len("andao"); len(elem) >= l && elem[0:l] == "andao" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetStateRandaoRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									case 'o': // Prefix: "oot"
										origElem := elem
										if l := len("oot"); len(elem) >= l && elem[0:l] == "oot" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetStateRootRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								case 's': // Prefix: "sync_committees"
									origElem := elem
									if l := len("sync_committees"); len(elem) >= l && elem[0:l] == "sync_committees" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetEpochSyncCommitteesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 'v': // Prefix: "validator"
									origElem := elem
									if l := len("validator"); len(elem) >= l && elem[0:l] == "validator" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '_': // Prefix: "_balances"
										origElem := elem
										if l := len("_balances"); len(elem) >= l && elem[0:l] == "_balances" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetStateValidatorBalancesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handlePostStateValidatorBalancesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}

										elem = origElem
									case 's': // Prefix: "s"
										origElem := elem
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetStateValidatorsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "validator_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetStateValidatorRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 'u': // Prefix: "uilder/states/"
						origElem := elem
						if l := len("uilder/states/"); len(elem) >= l && elem[0:l] == "uilder/states/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "state_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/expected_withdrawals"
							origElem := elem
							if l := len("/expected_withdrawals"); len(elem) >= l && elem[0:l] == "/expected_withdrawals" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetNextWithdrawalsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'c': // Prefix: "config/"
					origElem := elem
					if l := len("config/"); len(elem) >= l && elem[0:l] == "config/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "deposit_contract"
						origElem := elem
						if l := len("deposit_contract"); len(elem) >= l && elem[0:l] == "deposit_contract" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetDepositContractRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 'f': // Prefix: "fork_schedule"
						origElem := elem
						if l := len("fork_schedule"); len(elem) >= l && elem[0:l] == "fork_schedule" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetForkScheduleRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 's': // Prefix: "spec"
						origElem := elem
						if l := len("spec"); len(elem) >= l && elem[0:l] == "spec" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetSpecRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'd': // Prefix: "debug/fork_choice"
					origElem := elem
					if l := len("debug/fork_choice"); len(elem) >= l && elem[0:l] == "debug/fork_choice" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetDebugForkChoiceRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

					elem = origElem
				case 'e': // Prefix: "events"
					origElem := elem
					if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleEventstreamRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

					elem = origElem
				case 'n': // Prefix: "node/"
					origElem := elem
					if l := len("node/"); len(elem) >= l && elem[0:l] == "node/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'h': // Prefix: "health"
						origElem := elem
						if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetHealthRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 'i': // Prefix: "identity"
						origElem := elem
						if l := len("identity"); len(elem) >= l && elem[0:l] == "identity" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetNetworkIdentityRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 'p': // Prefix: "peer"
						origElem := elem
						if l := len("peer"); len(elem) >= l && elem[0:l] == "peer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '_': // Prefix: "_count"
							origElem := elem
							if l := len("_count"); len(elem) >= l && elem[0:l] == "_count" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetPeerCountRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPeersRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "peer_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPeerRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 's': // Prefix: "syncing"
						origElem := elem
						if l := len("syncing"); len(elem) >= l && elem[0:l] == "syncing" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetSyncingStatusRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 'v': // Prefix: "version"
						origElem := elem
						if l := len("version"); len(elem) >= l && elem[0:l] == "version" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetNodeVersionRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'v': // Prefix: "validator/"
					origElem := elem
					if l := len("validator/"); len(elem) >= l && elem[0:l] == "validator/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "a"
						origElem := elem
						if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "ggregate_a"
							origElem := elem
							if l := len("ggregate_a"); len(elem) >= l && elem[0:l] == "ggregate_a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'n': // Prefix: "nd_proofs"
								origElem := elem
								if l := len("nd_proofs"); len(elem) >= l && elem[0:l] == "nd_proofs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handlePublishAggregateAndProofsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 't': // Prefix: "ttestation"
								origElem := elem
								if l := len("ttestation"); len(elem) >= l && elem[0:l] == "ttestation" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetAggregatedAttestationRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 't': // Prefix: "ttestation_data"
							origElem := elem
							if l := len("ttestation_data"); len(elem) >= l && elem[0:l] == "ttestation_data" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleProduceAttestationDataRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					case 'b': // Prefix: "b"
						origElem := elem
						if l := len("b"); len(elem) >= l && elem[0:l] == "b" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "eacon_committee_s"
							origElem := elem
							if l := len("eacon_committee_s"); len(elem) >= l && elem[0:l] == "eacon_committee_s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "elections"
								origElem := elem
								if l := len("elections"); len(elem) >= l && elem[0:l] == "elections" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleSubmitBeaconCommitteeSelectionsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'u': // Prefix: "ubscriptions"
								origElem := elem
								if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handlePrepareBeaconCommitteeSubnetRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'l': // Prefix: "linded_blocks/"
							origElem := elem
							if l := len("linded_blocks/"); len(elem) >= l && elem[0:l] == "linded_blocks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "slot"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleProduceBlindedBlockRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					case 'c': // Prefix: "contribution_and_proofs"
						origElem := elem
						if l := len("contribution_and_proofs"); len(elem) >= l && elem[0:l] == "contribution_and_proofs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePublishContributionAndProofsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 'd': // Prefix: "duties/"
						origElem := elem
						if l := len("duties/"); len(elem) >= l && elem[0:l] == "duties/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "attester/"
							origElem := elem
							if l := len("attester/"); len(elem) >= l && elem[0:l] == "attester/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleGetAttesterDutiesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						case 'p': // Prefix: "proposer/"
							origElem := elem
							if l := len("proposer/"); len(elem) >= l && elem[0:l] == "proposer/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetProposerDutiesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "sync/"
							origElem := elem
							if l := len("sync/"); len(elem) >= l && elem[0:l] == "sync/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleGetSyncCommitteeDutiesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					case 'l': // Prefix: "liveness/"
						origElem := elem
						if l := len("liveness/"); len(elem) >= l && elem[0:l] == "liveness/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "epoch"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleGetLivenessRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 'p': // Prefix: "prepare_beacon_proposer"
						origElem := elem
						if l := len("prepare_beacon_proposer"); len(elem) >= l && elem[0:l] == "prepare_beacon_proposer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePrepareBeaconProposerRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 'r': // Prefix: "register_validator"
						origElem := elem
						if l := len("register_validator"); len(elem) >= l && elem[0:l] == "register_validator" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleRegisterValidatorRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 's': // Prefix: "sync_committee_"
						origElem := elem
						if l := len("sync_committee_"); len(elem) >= l && elem[0:l] == "sync_committee_" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "contribution"
							origElem := elem
							if l := len("contribution"); len(elem) >= l && elem[0:l] == "contribution" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleProduceSyncCommitteeContributionRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "elections"
								origElem := elem
								if l := len("elections"); len(elem) >= l && elem[0:l] == "elections" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleSubmitSyncCommitteeSelectionsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'u': // Prefix: "ubscriptions"
								origElem := elem
								if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handlePrepareSyncCommitteeSubnetsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case '2': // Prefix: "2/"
				origElem := elem
				if l := len("2/"); len(elem) >= l && elem[0:l] == "2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "beacon/bl"
					origElem := elem
					if l := len("beacon/bl"); len(elem) >= l && elem[0:l] == "beacon/bl" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "inded_blocks"
						origElem := elem
						if l := len("inded_blocks"); len(elem) >= l && elem[0:l] == "inded_blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handlePublishBlindedBlockV2Request([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					case 'o': // Prefix: "ocks"
						origElem := elem
						if l := len("ocks"); len(elem) >= l && elem[0:l] == "ocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "POST":
								s.handlePublishBlockV2Request([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "block_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetBlockV2Request([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'd': // Prefix: "debug/beacon/"
					origElem := elem
					if l := len("debug/beacon/"); len(elem) >= l && elem[0:l] == "debug/beacon/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'h': // Prefix: "heads"
						origElem := elem
						if l := len("heads"); len(elem) >= l && elem[0:l] == "heads" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetDebugChainHeadsV2Request([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 's': // Prefix: "states/"
						origElem := elem
						if l := len("states/"); len(elem) >= l && elem[0:l] == "states/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "state_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetStateV2Request([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'v': // Prefix: "validator/blocks/"
					origElem := elem
					if l := len("validator/blocks/"); len(elem) >= l && elem[0:l] == "validator/blocks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "slot"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleProduceBlockV2Request([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case '3': // Prefix: "3/validator/blocks/"
				origElem := elem
				if l := len("3/validator/blocks/"); len(elem) >= l && elem[0:l] == "3/validator/blocks/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "slot"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleProduceBlockV3Request([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [2]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/eth/v"
			origElem := elem
			if l := len("/eth/v"); len(elem) >= l && elem[0:l] == "/eth/v" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case '1': // Prefix: "1/"
				origElem := elem
				if l := len("1/"); len(elem) >= l && elem[0:l] == "1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "b"
					origElem := elem
					if l := len("b"); len(elem) >= l && elem[0:l] == "b" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "eacon/"
						origElem := elem
						if l := len("eacon/"); len(elem) >= l && elem[0:l] == "eacon/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "bl"
							origElem := elem
							if l := len("bl"); len(elem) >= l && elem[0:l] == "bl" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "inded_blocks"
								origElem := elem
								if l := len("inded_blocks"); len(elem) >= l && elem[0:l] == "inded_blocks" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = "PublishBlindedBlock"
										r.summary = "Publish a signed block."
										r.operationID = "publishBlindedBlock"
										r.pathPattern = "/eth/v1/beacon/blinded_blocks"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "block_id"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetBlindedBlock
											r.name = "GetBlindedBlock"
											r.summary = "Get blinded block"
											r.operationID = "getBlindedBlock"
											r.pathPattern = "/eth/v1/beacon/blinded_blocks/{block_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'o': // Prefix: "o"
								origElem := elem
								if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "b_sidecars/"
									origElem := elem
									if l := len("b_sidecars/"); len(elem) >= l && elem[0:l] == "b_sidecars/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "block_id"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetBlobSidecars
											r.name = "GetBlobSidecars"
											r.summary = "Get blob sidecars"
											r.operationID = "getBlobSidecars"
											r.pathPattern = "/eth/v1/beacon/blob_sidecars/{block_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'c': // Prefix: "cks"
									origElem := elem
									if l := len("cks"); len(elem) >= l && elem[0:l] == "cks" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = "PublishBlock"
											r.summary = "Publish a signed block."
											r.operationID = "publishBlock"
											r.pathPattern = "/eth/v1/beacon/blocks"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "block_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "attestations"
												origElem := elem
												if l := len("attestations"); len(elem) >= l && elem[0:l] == "attestations" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: GetBlockAttestations
														r.name = "GetBlockAttestations"
														r.summary = "Get block attestations"
														r.operationID = "getBlockAttestations"
														r.pathPattern = "/eth/v1/beacon/blocks/{block_id}/attestations"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											case 'r': // Prefix: "root"
												origElem := elem
												if l := len("root"); len(elem) >= l && elem[0:l] == "root" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: GetBlockRoot
														r.name = "GetBlockRoot"
														r.summary = "Get block root"
														r.operationID = "getBlockRoot"
														r.pathPattern = "/eth/v1/beacon/blocks/{block_id}/root"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'd': // Prefix: "deposit_snapshot"
							origElem := elem
							if l := len("deposit_snapshot"); len(elem) >= l && elem[0:l] == "deposit_snapshot" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetDepositSnapshot
									r.name = "GetDepositSnapshot"
									r.summary = "Get Deposit Tree Snapshot"
									r.operationID = "getDepositSnapshot"
									r.pathPattern = "/eth/v1/beacon/deposit_snapshot"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'g': // Prefix: "genesis"
							origElem := elem
							if l := len("genesis"); len(elem) >= l && elem[0:l] == "genesis" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetGenesis
									r.name = "GetGenesis"
									r.summary = "Retrieve details of the chain's genesis."
									r.operationID = "getGenesis"
									r.pathPattern = "/eth/v1/beacon/genesis"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'h': // Prefix: "headers"
							origElem := elem
							if l := len("headers"); len(elem) >= l && elem[0:l] == "headers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetBlockHeaders"
									r.summary = "Get block headers"
									r.operationID = "getBlockHeaders"
									r.pathPattern = "/eth/v1/beacon/headers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetBlockHeader
										r.name = "GetBlockHeader"
										r.summary = "Get block header"
										r.operationID = "getBlockHeader"
										r.pathPattern = "/eth/v1/beacon/headers/{block_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'l': // Prefix: "light_client/"
							origElem := elem
							if l := len("light_client/"); len(elem) >= l && elem[0:l] == "light_client/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "bootstrap/"
								origElem := elem
								if l := len("bootstrap/"); len(elem) >= l && elem[0:l] == "bootstrap/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_root"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetLightClientBootstrap
										r.name = "GetLightClientBootstrap"
										r.summary = "Get `LightClientBootstrap` structure for a requested block root"
										r.operationID = "getLightClientBootstrap"
										r.pathPattern = "/eth/v1/beacon/light_client/bootstrap/{block_root}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'f': // Prefix: "finality_update"
								origElem := elem
								if l := len("finality_update"); len(elem) >= l && elem[0:l] == "finality_update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetLightClientFinalityUpdate
										r.name = "GetLightClientFinalityUpdate"
										r.summary = "Get the latest known `LightClientFinalityUpdate`"
										r.operationID = "getLightClientFinalityUpdate"
										r.pathPattern = "/eth/v1/beacon/light_client/finality_update"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'o': // Prefix: "optimistic_update"
								origElem := elem
								if l := len("optimistic_update"); len(elem) >= l && elem[0:l] == "optimistic_update" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetLightClientOptimisticUpdate
										r.name = "GetLightClientOptimisticUpdate"
										r.summary = "Get the latest known `LightClientOptimisticUpdate`"
										r.operationID = "getLightClientOptimisticUpdate"
										r.pathPattern = "/eth/v1/beacon/light_client/optimistic_update"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'u': // Prefix: "updates"
								origElem := elem
								if l := len("updates"); len(elem) >= l && elem[0:l] == "updates" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetLightClientUpdatesByRange
										r.name = "GetLightClientUpdatesByRange"
										r.summary = "Get `LightClientUpdate` instances in a requested sync committee period range"
										r.operationID = "getLightClientUpdatesByRange"
										r.pathPattern = "/eth/v1/beacon/light_client/updates"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'p': // Prefix: "pool/"
							origElem := elem
							if l := len("pool/"); len(elem) >= l && elem[0:l] == "pool/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "attest"
								origElem := elem
								if l := len("attest"); len(elem) >= l && elem[0:l] == "attest" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "ations"
									origElem := elem
									if l := len("ations"); len(elem) >= l && elem[0:l] == "ations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetPoolAttestations
											r.name = "GetPoolAttestations"
											r.summary = "Get Attestations from operations pool"
											r.operationID = "getPoolAttestations"
											r.pathPattern = "/eth/v1/beacon/pool/attestations"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											// Leaf: SubmitPoolAttestations
											r.name = "SubmitPoolAttestations"
											r.summary = "Submit Attestation objects to node"
											r.operationID = "submitPoolAttestations"
											r.pathPattern = "/eth/v1/beacon/pool/attestations"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'e': // Prefix: "er_slashings"
									origElem := elem
									if l := len("er_slashings"); len(elem) >= l && elem[0:l] == "er_slashings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetPoolAttesterSlashings
											r.name = "GetPoolAttesterSlashings"
											r.summary = "Get AttesterSlashings from operations pool"
											r.operationID = "getPoolAttesterSlashings"
											r.pathPattern = "/eth/v1/beacon/pool/attester_slashings"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											// Leaf: SubmitPoolAttesterSlashings
											r.name = "SubmitPoolAttesterSlashings"
											r.summary = "Submit AttesterSlashing object to node's pool"
											r.operationID = "submitPoolAttesterSlashings"
											r.pathPattern = "/eth/v1/beacon/pool/attester_slashings"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'b': // Prefix: "bls_to_execution_changes"
								origElem := elem
								if l := len("bls_to_execution_changes"); len(elem) >= l && elem[0:l] == "bls_to_execution_changes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPoolBLSToExecutionChanges
										r.name = "GetPoolBLSToExecutionChanges"
										r.summary = "Get SignedBLSToExecutionChange from operations pool"
										r.operationID = "getPoolBLSToExecutionChanges"
										r.pathPattern = "/eth/v1/beacon/pool/bls_to_execution_changes"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										// Leaf: SubmitPoolBLSToExecutionChange
										r.name = "SubmitPoolBLSToExecutionChange"
										r.summary = "Submit SignedBLSToExecutionChange object to node's pool"
										r.operationID = "submitPoolBLSToExecutionChange"
										r.pathPattern = "/eth/v1/beacon/pool/bls_to_execution_changes"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'p': // Prefix: "proposer_slashings"
								origElem := elem
								if l := len("proposer_slashings"); len(elem) >= l && elem[0:l] == "proposer_slashings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPoolProposerSlashings
										r.name = "GetPoolProposerSlashings"
										r.summary = "Get ProposerSlashings from operations pool"
										r.operationID = "getPoolProposerSlashings"
										r.pathPattern = "/eth/v1/beacon/pool/proposer_slashings"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										// Leaf: SubmitPoolProposerSlashings
										r.name = "SubmitPoolProposerSlashings"
										r.summary = "Submit ProposerSlashing object to node's pool"
										r.operationID = "submitPoolProposerSlashings"
										r.pathPattern = "/eth/v1/beacon/pool/proposer_slashings"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "sync_committees"
								origElem := elem
								if l := len("sync_committees"); len(elem) >= l && elem[0:l] == "sync_committees" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: SubmitPoolSyncCommitteeSignatures
										r.name = "SubmitPoolSyncCommitteeSignatures"
										r.summary = "Submit sync committee signatures to node"
										r.operationID = "submitPoolSyncCommitteeSignatures"
										r.pathPattern = "/eth/v1/beacon/pool/sync_committees"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'v': // Prefix: "voluntary_exits"
								origElem := elem
								if l := len("voluntary_exits"); len(elem) >= l && elem[0:l] == "voluntary_exits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPoolVoluntaryExits
										r.name = "GetPoolVoluntaryExits"
										r.summary = "Get SignedVoluntaryExit from operations pool"
										r.operationID = "getPoolVoluntaryExits"
										r.pathPattern = "/eth/v1/beacon/pool/voluntary_exits"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										// Leaf: SubmitPoolVoluntaryExit
										r.name = "SubmitPoolVoluntaryExit"
										r.summary = "Submit SignedVoluntaryExit object to node's pool"
										r.operationID = "submitPoolVoluntaryExit"
										r.pathPattern = "/eth/v1/beacon/pool/voluntary_exits"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "rewards/"
							origElem := elem
							if l := len("rewards/"); len(elem) >= l && elem[0:l] == "rewards/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "attestations/"
								origElem := elem
								if l := len("attestations/"); len(elem) >= l && elem[0:l] == "attestations/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "epoch"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: GetAttestationsRewards
										r.name = "GetAttestationsRewards"
										r.summary = "Get attestations rewards"
										r.operationID = "getAttestationsRewards"
										r.pathPattern = "/eth/v1/beacon/rewards/attestations/{epoch}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'b': // Prefix: "blocks/"
								origElem := elem
								if l := len("blocks/"); len(elem) >= l && elem[0:l] == "blocks/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetBlockRewards
										r.name = "GetBlockRewards"
										r.summary = "Get block rewards"
										r.operationID = "getBlockRewards"
										r.pathPattern = "/eth/v1/beacon/rewards/blocks/{block_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "sync_committee/"
								origElem := elem
								if l := len("sync_committee/"); len(elem) >= l && elem[0:l] == "sync_committee/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "block_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: GetSyncCommitteeRewards
										r.name = "GetSyncCommitteeRewards"
										r.summary = "Get sync committee rewards"
										r.operationID = "getSyncCommitteeRewards"
										r.pathPattern = "/eth/v1/beacon/rewards/sync_committee/{block_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "states/"
							origElem := elem
							if l := len("states/"); len(elem) >= l && elem[0:l] == "states/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "state_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "committees"
									origElem := elem
									if l := len("committees"); len(elem) >= l && elem[0:l] == "committees" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetEpochCommittees
											r.name = "GetEpochCommittees"
											r.summary = "Get all committees for a state."
											r.operationID = "getEpochCommittees"
											r.pathPattern = "/eth/v1/beacon/states/{state_id}/committees"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'f': // Prefix: "f"
									origElem := elem
									if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'i': // Prefix: "inality_checkpoints"
										origElem := elem
										if l := len("inality_checkpoints"); len(elem) >= l && elem[0:l] == "inality_checkpoints" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetStateFinalityCheckpoints
												r.name = "GetStateFinalityCheckpoints"
												r.summary = "Get state finality checkpoints"
												r.operationID = "getStateFinalityCheckpoints"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/finality_checkpoints"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'o': // Prefix: "ork"
										origElem := elem
										if l := len("ork"); len(elem) >= l && elem[0:l] == "ork" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetStateFork
												r.name = "GetStateFork"
												r.summary = "Get Fork object for requested state"
												r.operationID = "getStateFork"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/fork"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								case 'r': // Prefix: "r"
									origElem := elem
									if l := len("r"); len(elem) >= l && elem[0:l] == "r" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "andao"
										origElem := elem
										if l := len("andao"); len(elem) >= l && elem[0:l] == "andao" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetStateRandao
												r.name = "GetStateRandao"
												r.summary = "Get the RANDAO mix for some epoch in a specified state."
												r.operationID = "getStateRandao"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/randao"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'o': // Prefix: "oot"
										origElem := elem
										if l := len("oot"); len(elem) >= l && elem[0:l] == "oot" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetStateRoot
												r.name = "GetStateRoot"
												r.summary = "Get state SSZ HashTreeRoot"
												r.operationID = "getStateRoot"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/root"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								case 's': // Prefix: "sync_committees"
									origElem := elem
									if l := len("sync_committees"); len(elem) >= l && elem[0:l] == "sync_committees" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetEpochSyncCommittees
											r.name = "GetEpochSyncCommittees"
											r.summary = "Get sync committees for a state."
											r.operationID = "getEpochSyncCommittees"
											r.pathPattern = "/eth/v1/beacon/states/{state_id}/sync_committees"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'v': // Prefix: "validator"
									origElem := elem
									if l := len("validator"); len(elem) >= l && elem[0:l] == "validator" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '_': // Prefix: "_balances"
										origElem := elem
										if l := len("_balances"); len(elem) >= l && elem[0:l] == "_balances" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetStateValidatorBalances
												r.name = "GetStateValidatorBalances"
												r.summary = "Get validator balances from state"
												r.operationID = "getStateValidatorBalances"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/validator_balances"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												// Leaf: PostStateValidatorBalances
												r.name = "PostStateValidatorBalances"
												r.summary = "Get validator balances from state"
												r.operationID = "postStateValidatorBalances"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/validator_balances"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 's': // Prefix: "s"
										origElem := elem
										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "GetStateValidators"
												r.summary = "Get validators from state"
												r.operationID = "getStateValidators"
												r.pathPattern = "/eth/v1/beacon/states/{state_id}/validators"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											origElem := elem
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "validator_id"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: GetStateValidator
													r.name = "GetStateValidator"
													r.summary = "Get validator from state by id"
													r.operationID = "getStateValidator"
													r.pathPattern = "/eth/v1/beacon/states/{state_id}/validators/{validator_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 'u': // Prefix: "uilder/states/"
						origElem := elem
						if l := len("uilder/states/"); len(elem) >= l && elem[0:l] == "uilder/states/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "state_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/expected_withdrawals"
							origElem := elem
							if l := len("/expected_withdrawals"); len(elem) >= l && elem[0:l] == "/expected_withdrawals" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetNextWithdrawals
									r.name = "GetNextWithdrawals"
									r.summary = "Get the withdrawals that are to be included for the block built on the specified state."
									r.operationID = "getNextWithdrawals"
									r.pathPattern = "/eth/v1/builder/states/{state_id}/expected_withdrawals"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'c': // Prefix: "config/"
					origElem := elem
					if l := len("config/"); len(elem) >= l && elem[0:l] == "config/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "deposit_contract"
						origElem := elem
						if l := len("deposit_contract"); len(elem) >= l && elem[0:l] == "deposit_contract" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetDepositContract
								r.name = "GetDepositContract"
								r.summary = "Get deposit contract address."
								r.operationID = "getDepositContract"
								r.pathPattern = "/eth/v1/config/deposit_contract"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'f': // Prefix: "fork_schedule"
						origElem := elem
						if l := len("fork_schedule"); len(elem) >= l && elem[0:l] == "fork_schedule" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetForkSchedule
								r.name = "GetForkSchedule"
								r.summary = "Get scheduled upcoming forks."
								r.operationID = "getForkSchedule"
								r.pathPattern = "/eth/v1/config/fork_schedule"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 's': // Prefix: "spec"
						origElem := elem
						if l := len("spec"); len(elem) >= l && elem[0:l] == "spec" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetSpec
								r.name = "GetSpec"
								r.summary = "Get spec params."
								r.operationID = "getSpec"
								r.pathPattern = "/eth/v1/config/spec"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'd': // Prefix: "debug/fork_choice"
					origElem := elem
					if l := len("debug/fork_choice"); len(elem) >= l && elem[0:l] == "debug/fork_choice" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: GetDebugForkChoice
							r.name = "GetDebugForkChoice"
							r.summary = "Get fork choice array"
							r.operationID = "getDebugForkChoice"
							r.pathPattern = "/eth/v1/debug/fork_choice"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				case 'e': // Prefix: "events"
					origElem := elem
					if l := len("events"); len(elem) >= l && elem[0:l] == "events" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: Eventstream
							r.name = "Eventstream"
							r.summary = "Subscribe to beacon node events"
							r.operationID = "eventstream"
							r.pathPattern = "/eth/v1/events"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

					elem = origElem
				case 'n': // Prefix: "node/"
					origElem := elem
					if l := len("node/"); len(elem) >= l && elem[0:l] == "node/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'h': // Prefix: "health"
						origElem := elem
						if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetHealth
								r.name = "GetHealth"
								r.summary = "Get health check"
								r.operationID = "getHealth"
								r.pathPattern = "/eth/v1/node/health"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'i': // Prefix: "identity"
						origElem := elem
						if l := len("identity"); len(elem) >= l && elem[0:l] == "identity" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetNetworkIdentity
								r.name = "GetNetworkIdentity"
								r.summary = "Get node network identity"
								r.operationID = "getNetworkIdentity"
								r.pathPattern = "/eth/v1/node/identity"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'p': // Prefix: "peer"
						origElem := elem
						if l := len("peer"); len(elem) >= l && elem[0:l] == "peer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '_': // Prefix: "_count"
							origElem := elem
							if l := len("_count"); len(elem) >= l && elem[0:l] == "_count" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetPeerCount
									r.name = "GetPeerCount"
									r.summary = "Get peer count"
									r.operationID = "getPeerCount"
									r.pathPattern = "/eth/v1/node/peer_count"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetPeers"
									r.summary = "Get node network peers"
									r.operationID = "getPeers"
									r.pathPattern = "/eth/v1/node/peers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "peer_id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPeer
										r.name = "GetPeer"
										r.summary = "Get peer"
										r.operationID = "getPeer"
										r.pathPattern = "/eth/v1/node/peers/{peer_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					case 's': // Prefix: "syncing"
						origElem := elem
						if l := len("syncing"); len(elem) >= l && elem[0:l] == "syncing" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetSyncingStatus
								r.name = "GetSyncingStatus"
								r.summary = "Get node syncing status"
								r.operationID = "getSyncingStatus"
								r.pathPattern = "/eth/v1/node/syncing"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'v': // Prefix: "version"
						origElem := elem
						if l := len("version"); len(elem) >= l && elem[0:l] == "version" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetNodeVersion
								r.name = "GetNodeVersion"
								r.summary = "Get version string of the running beacon node."
								r.operationID = "getNodeVersion"
								r.pathPattern = "/eth/v1/node/version"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'v': // Prefix: "validator/"
					origElem := elem
					if l := len("validator/"); len(elem) >= l && elem[0:l] == "validator/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "a"
						origElem := elem
						if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "ggregate_a"
							origElem := elem
							if l := len("ggregate_a"); len(elem) >= l && elem[0:l] == "ggregate_a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'n': // Prefix: "nd_proofs"
								origElem := elem
								if l := len("nd_proofs"); len(elem) >= l && elem[0:l] == "nd_proofs" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: PublishAggregateAndProofs
										r.name = "PublishAggregateAndProofs"
										r.summary = "Publish multiple aggregate and proofs"
										r.operationID = "publishAggregateAndProofs"
										r.pathPattern = "/eth/v1/validator/aggregate_and_proofs"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 't': // Prefix: "ttestation"
								origElem := elem
								if l := len("ttestation"); len(elem) >= l && elem[0:l] == "ttestation" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetAggregatedAttestation
										r.name = "GetAggregatedAttestation"
										r.summary = "Get aggregated attestation"
										r.operationID = "getAggregatedAttestation"
										r.pathPattern = "/eth/v1/validator/aggregate_attestation"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 't': // Prefix: "ttestation_data"
							origElem := elem
							if l := len("ttestation_data"); len(elem) >= l && elem[0:l] == "ttestation_data" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ProduceAttestationData
									r.name = "ProduceAttestationData"
									r.summary = "Produce an attestation data"
									r.operationID = "produceAttestationData"
									r.pathPattern = "/eth/v1/validator/attestation_data"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					case 'b': // Prefix: "b"
						origElem := elem
						if l := len("b"); len(elem) >= l && elem[0:l] == "b" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "eacon_committee_s"
							origElem := elem
							if l := len("eacon_committee_s"); len(elem) >= l && elem[0:l] == "eacon_committee_s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "elections"
								origElem := elem
								if l := len("elections"); len(elem) >= l && elem[0:l] == "elections" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: SubmitBeaconCommitteeSelections
										r.name = "SubmitBeaconCommitteeSelections"
										r.summary = "Determine if a distributed validator has been selected to aggregate attestations"
										r.operationID = "submitBeaconCommitteeSelections"
										r.pathPattern = "/eth/v1/validator/beacon_committee_selections"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'u': // Prefix: "ubscriptions"
								origElem := elem
								if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: PrepareBeaconCommitteeSubnet
										r.name = "PrepareBeaconCommitteeSubnet"
										r.summary = "Signal beacon node to prepare for a committee subnet"
										r.operationID = "prepareBeaconCommitteeSubnet"
										r.pathPattern = "/eth/v1/validator/beacon_committee_subscriptions"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'l': // Prefix: "linded_blocks/"
							origElem := elem
							if l := len("linded_blocks/"); len(elem) >= l && elem[0:l] == "linded_blocks/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "slot"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ProduceBlindedBlock
									r.name = "ProduceBlindedBlock"
									r.summary = "Produce a new blinded block, without signature."
									r.operationID = "produceBlindedBlock"
									r.pathPattern = "/eth/v1/validator/blinded_blocks/{slot}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					case 'c': // Prefix: "contribution_and_proofs"
						origElem := elem
						if l := len("contribution_and_proofs"); len(elem) >= l && elem[0:l] == "contribution_and_proofs" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PublishContributionAndProofs
								r.name = "PublishContributionAndProofs"
								r.summary = "Publish multiple contribution and proofs"
								r.operationID = "publishContributionAndProofs"
								r.pathPattern = "/eth/v1/validator/contribution_and_proofs"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'd': // Prefix: "duties/"
						origElem := elem
						if l := len("duties/"); len(elem) >= l && elem[0:l] == "duties/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "attester/"
							origElem := elem
							if l := len("attester/"); len(elem) >= l && elem[0:l] == "attester/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: GetAttesterDuties
									r.name = "GetAttesterDuties"
									r.summary = "Get attester duties"
									r.operationID = "getAttesterDuties"
									r.pathPattern = "/eth/v1/validator/duties/attester/{epoch}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'p': // Prefix: "proposer/"
							origElem := elem
							if l := len("proposer/"); len(elem) >= l && elem[0:l] == "proposer/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetProposerDuties
									r.name = "GetProposerDuties"
									r.summary = "Get block proposers duties"
									r.operationID = "getProposerDuties"
									r.pathPattern = "/eth/v1/validator/duties/proposer/{epoch}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "sync/"
							origElem := elem
							if l := len("sync/"); len(elem) >= l && elem[0:l] == "sync/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "epoch"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: GetSyncCommitteeDuties
									r.name = "GetSyncCommitteeDuties"
									r.summary = "Get sync committee duties"
									r.operationID = "getSyncCommitteeDuties"
									r.pathPattern = "/eth/v1/validator/duties/sync/{epoch}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					case 'l': // Prefix: "liveness/"
						origElem := elem
						if l := len("liveness/"); len(elem) >= l && elem[0:l] == "liveness/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "epoch"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: GetLiveness
								r.name = "GetLiveness"
								r.summary = "Indicates if a validator has been observed on the network"
								r.operationID = "getLiveness"
								r.pathPattern = "/eth/v1/validator/liveness/{epoch}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'p': // Prefix: "prepare_beacon_proposer"
						origElem := elem
						if l := len("prepare_beacon_proposer"); len(elem) >= l && elem[0:l] == "prepare_beacon_proposer" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PrepareBeaconProposer
								r.name = "PrepareBeaconProposer"
								r.summary = "Provide beacon node with proposals for the given validators."
								r.operationID = "prepareBeaconProposer"
								r.pathPattern = "/eth/v1/validator/prepare_beacon_proposer"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'r': // Prefix: "register_validator"
						origElem := elem
						if l := len("register_validator"); len(elem) >= l && elem[0:l] == "register_validator" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: RegisterValidator
								r.name = "RegisterValidator"
								r.summary = "Provide beacon node with registrations for the given validators to the external builder network."
								r.operationID = "registerValidator"
								r.pathPattern = "/eth/v1/validator/register_validator"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 's': // Prefix: "sync_committee_"
						origElem := elem
						if l := len("sync_committee_"); len(elem) >= l && elem[0:l] == "sync_committee_" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'c': // Prefix: "contribution"
							origElem := elem
							if l := len("contribution"); len(elem) >= l && elem[0:l] == "contribution" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ProduceSyncCommitteeContribution
									r.name = "ProduceSyncCommitteeContribution"
									r.summary = "Produce a sync committee contribution"
									r.operationID = "produceSyncCommitteeContribution"
									r.pathPattern = "/eth/v1/validator/sync_committee_contribution"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "elections"
								origElem := elem
								if l := len("elections"); len(elem) >= l && elem[0:l] == "elections" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: SubmitSyncCommitteeSelections
										r.name = "SubmitSyncCommitteeSelections"
										r.summary = "Determine if a distributed validator has been selected to make a sync committee contribution"
										r.operationID = "submitSyncCommitteeSelections"
										r.pathPattern = "/eth/v1/validator/sync_committee_selections"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'u': // Prefix: "ubscriptions"
								origElem := elem
								if l := len("ubscriptions"); len(elem) >= l && elem[0:l] == "ubscriptions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: PrepareSyncCommitteeSubnets
										r.name = "PrepareSyncCommitteeSubnets"
										r.summary = "Subscribe to sync committee subnets"
										r.operationID = "prepareSyncCommitteeSubnets"
										r.pathPattern = "/eth/v1/validator/sync_committee_subscriptions"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case '2': // Prefix: "2/"
				origElem := elem
				if l := len("2/"); len(elem) >= l && elem[0:l] == "2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "beacon/bl"
					origElem := elem
					if l := len("beacon/bl"); len(elem) >= l && elem[0:l] == "beacon/bl" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "inded_blocks"
						origElem := elem
						if l := len("inded_blocks"); len(elem) >= l && elem[0:l] == "inded_blocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: PublishBlindedBlockV2
								r.name = "PublishBlindedBlockV2"
								r.summary = "Publish a signed block."
								r.operationID = "publishBlindedBlockV2"
								r.pathPattern = "/eth/v2/beacon/blinded_blocks"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 'o': // Prefix: "ocks"
						origElem := elem
						if l := len("ocks"); len(elem) >= l && elem[0:l] == "ocks" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								r.name = "PublishBlockV2"
								r.summary = "Publish a signed block."
								r.operationID = "publishBlockV2"
								r.pathPattern = "/eth/v2/beacon/blocks"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							origElem := elem
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "block_id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetBlockV2
									r.name = "GetBlockV2"
									r.summary = "Get block"
									r.operationID = "getBlockV2"
									r.pathPattern = "/eth/v2/beacon/blocks/{block_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				case 'd': // Prefix: "debug/beacon/"
					origElem := elem
					if l := len("debug/beacon/"); len(elem) >= l && elem[0:l] == "debug/beacon/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'h': // Prefix: "heads"
						origElem := elem
						if l := len("heads"); len(elem) >= l && elem[0:l] == "heads" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetDebugChainHeadsV2
								r.name = "GetDebugChainHeadsV2"
								r.summary = "Get fork choice leaves"
								r.operationID = "getDebugChainHeadsV2"
								r.pathPattern = "/eth/v2/debug/beacon/heads"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 's': // Prefix: "states/"
						origElem := elem
						if l := len("states/"); len(elem) >= l && elem[0:l] == "states/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "state_id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetStateV2
								r.name = "GetStateV2"
								r.summary = "Get full BeaconState object"
								r.operationID = "getStateV2"
								r.pathPattern = "/eth/v2/debug/beacon/states/{state_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'v': // Prefix: "validator/blocks/"
					origElem := elem
					if l := len("validator/blocks/"); len(elem) >= l && elem[0:l] == "validator/blocks/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "slot"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: ProduceBlockV2
							r.name = "ProduceBlockV2"
							r.summary = "Produce a new block, without signature."
							r.operationID = "produceBlockV2"
							r.pathPattern = "/eth/v2/validator/blocks/{slot}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case '3': // Prefix: "3/validator/blocks/"
				origElem := elem
				if l := len("3/validator/blocks/"); len(elem) >= l && elem[0:l] == "3/validator/blocks/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "slot"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: ProduceBlockV3
						r.name = "ProduceBlockV3"
						r.summary = "Produce a new block, without signature."
						r.operationID = "produceBlockV3"
						r.pathPattern = "/eth/v3/validator/blocks/{slot}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	return r, false
}
