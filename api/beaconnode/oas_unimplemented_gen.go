// Code generated by ogen, DO NOT EDIT.

package beaconnode

import (
	"context"

	ht "github.com/ogen-go/ogen/http"
)

// UnimplementedHandler is no-op Handler which returns http.ErrNotImplemented.
type UnimplementedHandler struct{}

var _ Handler = UnimplementedHandler{}

// Eventstream implements eventstream operation.
//
// Provides endpoint to subscribe to beacon node Server-Sent-Events stream.
// Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.
// html#the-eventsource-interface)
// implementation to listen on those events.
// Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the
// event stream connection alive in the presence of proxy servers.
//
// GET /eth/v1/events
func (UnimplementedHandler) Eventstream(ctx context.Context, params EventstreamParams) (r EventstreamRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetAggregatedAttestation implements getAggregatedAttestation operation.
//
// Aggregates all attestations matching given attestation data root and slot.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the aggregated attestation attests
// to a block that has not been fully verified by an execution engine).
// A 404 error must be returned if no attestation is available for the requested
// `attestation_data_root`.
//
// GET /eth/v1/validator/aggregate_attestation
func (UnimplementedHandler) GetAggregatedAttestation(ctx context.Context, params GetAggregatedAttestationParams) (r GetAggregatedAttestationRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetAttestationsRewards implements getAttestationsRewards operation.
//
// Retrieve attestation reward info for validators specified by array of public keys or validator
// index. If no array is provided, return reward info for every validator.
//
// POST /eth/v1/beacon/rewards/attestations/{epoch}
func (UnimplementedHandler) GetAttestationsRewards(ctx context.Context, req []string, params GetAttestationsRewardsParams) (r GetAttestationsRewardsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetAttesterDuties implements getAttesterDuties operation.
//
// Requests the beacon node to provide a set of attestation duties, which should be performed by
// validators, for a particular epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization (of >
// MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you
// should monitor head events and confirm the dependent root in this response matches:
// - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1)
// - 1)` or the genesis block root in the case of underflow.
//
// POST /eth/v1/validator/duties/attester/{epoch}
func (UnimplementedHandler) GetAttesterDuties(ctx context.Context, req []string, params GetAttesterDutiesParams) (r GetAttesterDutiesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlindedBlock implements getBlindedBlock operation.
//
// Retrieves blinded block for given block ID.
// Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ.
//
// GET /eth/v1/beacon/blinded_blocks/{block_id}
func (UnimplementedHandler) GetBlindedBlock(ctx context.Context, params GetBlindedBlockParams) (r GetBlindedBlockRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlobSidecars implements getBlobSidecars operation.
//
// Retrieves blob sidecars for a given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
// If the `indices` parameter is specified, only the blob sidecars with the specified indices will be
// returned. There are no guarantees
// for the returned blob sidecars in terms of ordering.
//
// GET /eth/v1/beacon/blob_sidecars/{block_id}
func (UnimplementedHandler) GetBlobSidecars(ctx context.Context, params GetBlobSidecarsParams) (r GetBlobSidecarsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockAttestations implements getBlockAttestations operation.
//
// Retrieves attestation included in requested block.
//
// GET /eth/v1/beacon/blocks/{block_id}/attestations
func (UnimplementedHandler) GetBlockAttestations(ctx context.Context, params GetBlockAttestationsParams) (r GetBlockAttestationsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockHeader implements getBlockHeader operation.
//
// Retrieves block header for given block id.
//
// GET /eth/v1/beacon/headers/{block_id}
func (UnimplementedHandler) GetBlockHeader(ctx context.Context, params GetBlockHeaderParams) (r GetBlockHeaderRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockHeaders implements getBlockHeaders operation.
//
// Retrieves block headers matching given query. By default it will fetch current head slot blocks.
//
// GET /eth/v1/beacon/headers
func (UnimplementedHandler) GetBlockHeaders(ctx context.Context, params GetBlockHeadersParams) (r GetBlockHeadersRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockRewards implements getBlockRewards operation.
//
// Retrieve block reward info for a single block.
//
// GET /eth/v1/beacon/rewards/blocks/{block_id}
func (UnimplementedHandler) GetBlockRewards(ctx context.Context, params GetBlockRewardsParams) (r GetBlockRewardsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockRoot implements getBlockRoot operation.
//
// Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
//
// GET /eth/v1/beacon/blocks/{block_id}/root
func (UnimplementedHandler) GetBlockRoot(ctx context.Context, params GetBlockRootParams) (r GetBlockRootRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetBlockV2 implements getBlockV2 operation.
//
// Retrieves block details for given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/beacon/blocks/{block_id}
func (UnimplementedHandler) GetBlockV2(ctx context.Context, params GetBlockV2Params) (r GetBlockV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// GetDebugChainHeadsV2 implements getDebugChainHeadsV2 operation.
//
// Retrieves all possible chain heads (leaves of fork choice tree).
//
// GET /eth/v2/debug/beacon/heads
func (UnimplementedHandler) GetDebugChainHeadsV2(ctx context.Context) (r GetDebugChainHeadsV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// GetDebugForkChoice implements getDebugForkChoice operation.
//
// Retrieves all current fork choice context.
//
// GET /eth/v1/debug/fork_choice
func (UnimplementedHandler) GetDebugForkChoice(ctx context.Context) (r GetDebugForkChoiceRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetDepositContract implements getDepositContract operation.
//
// Retrieve Eth1 deposit contract address and chain ID.
//
// GET /eth/v1/config/deposit_contract
func (UnimplementedHandler) GetDepositContract(ctx context.Context) (r GetDepositContractRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetDepositSnapshot implements getDepositSnapshot operation.
//
// Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot.
// Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ.
//
// GET /eth/v1/beacon/deposit_snapshot
func (UnimplementedHandler) GetDepositSnapshot(ctx context.Context) (r GetDepositSnapshotRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetEpochCommittees implements getEpochCommittees operation.
//
// Retrieves the committees for the given state.
//
// GET /eth/v1/beacon/states/{state_id}/committees
func (UnimplementedHandler) GetEpochCommittees(ctx context.Context, params GetEpochCommitteesParams) (r GetEpochCommitteesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetEpochSyncCommittees implements getEpochSyncCommittees operation.
//
// Retrieves the current sync committee for the given state. Also returns the subcommittee
// assignments.
//
// GET /eth/v1/beacon/states/{state_id}/sync_committees
func (UnimplementedHandler) GetEpochSyncCommittees(ctx context.Context, params GetEpochSyncCommitteesParams) (r GetEpochSyncCommitteesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetForkSchedule implements getForkSchedule operation.
//
// Retrieve all forks, past present and future, of which this node is aware.
//
// GET /eth/v1/config/fork_schedule
func (UnimplementedHandler) GetForkSchedule(ctx context.Context) (r GetForkScheduleRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetGenesis implements getGenesis operation.
//
// Retrieve details of the chain's genesis which can be used to identify chain.
//
// GET /eth/v1/beacon/genesis
func (UnimplementedHandler) GetGenesis(ctx context.Context) (r GetGenesisRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetHealth implements getHealth operation.
//
// Returns node health status in http status codes. Useful for load balancers.
//
// GET /eth/v1/node/health
func (UnimplementedHandler) GetHealth(ctx context.Context, params GetHealthParams) (r GetHealthRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetLightClientBootstrap implements getLightClientBootstrap operation.
//
// Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a
// given post-Altair beacon block root.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to
// be known.
//
// GET /eth/v1/beacon/light_client/bootstrap/{block_root}
func (UnimplementedHandler) GetLightClientBootstrap(ctx context.Context, params GetLightClientBootstrapParams) (r GetLightClientBootstrapRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetLightClientFinalityUpdate implements getLightClientFinalityUpdate operation.
//
// Requests the latest [`LightClientFinalityUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientfinalityupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
//
// GET /eth/v1/beacon/light_client/finality_update
func (UnimplementedHandler) GetLightClientFinalityUpdate(ctx context.Context) (r GetLightClientFinalityUpdateRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetLightClientOptimisticUpdate implements getLightClientOptimisticUpdate operation.
//
// Requests the latest [`LightClientOptimisticUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientoptimisticupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
//
// GET /eth/v1/beacon/light_client/optimistic_update
func (UnimplementedHandler) GetLightClientOptimisticUpdate(ctx context.Context) (r GetLightClientOptimisticUpdateRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetLightClientUpdatesByRange implements getLightClientUpdatesByRange operation.
//
// Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee
// period range `[start_period, start_period + count)`, leading up to the current head sync committee
// period as selected by fork choice.
// Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_update). They MUST respond with at least the earliest known result within
// the requested range, and MUST send results in consecutive order (by period). The response MUST NOT
// contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration)
// results.
//
// GET /eth/v1/beacon/light_client/updates
func (UnimplementedHandler) GetLightClientUpdatesByRange(ctx context.Context, params GetLightClientUpdatesByRangeParams) (r GetLightClientUpdatesByRangeRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetLiveness implements getLiveness operation.
//
// Requests the beacon node to indicate if a validator has been observed to be live in a given epoch.
// The beacon node might detect liveness by observing messages from the validator on the network, in
// the beacon chain, from its API or from any other source. A beacon node SHOULD support the current
// and previous epoch, however it MAY support earlier epoch. It is important to note that the values
// returned by the beacon node are not canonical; they are best-effort and based upon a subjective
// view of the network. A beacon node that was recently started or suffered a network partition may
// indicate that a validator is not live when it actually is.
//
// POST /eth/v1/validator/liveness/{epoch}
func (UnimplementedHandler) GetLiveness(ctx context.Context, req []string, params GetLivenessParams) (r GetLivenessRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetNetworkIdentity implements getNetworkIdentity operation.
//
// Retrieves data about the node's network presence.
//
// GET /eth/v1/node/identity
func (UnimplementedHandler) GetNetworkIdentity(ctx context.Context) (r GetNetworkIdentityRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetNextWithdrawals implements getNextWithdrawals operation.
//
// Get the withdrawals computed from the specified state, that will be included in the block
// that gets built on the specified state.
//
// GET /eth/v1/builder/states/{state_id}/expected_withdrawals
func (UnimplementedHandler) GetNextWithdrawals(ctx context.Context, params GetNextWithdrawalsParams) (r GetNextWithdrawalsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetNodeVersion implements getNodeVersion operation.
//
// Requests that the beacon node identify information about its implementation in a format similar to
// a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
//
// GET /eth/v1/node/version
func (UnimplementedHandler) GetNodeVersion(ctx context.Context) (r GetNodeVersionRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPeer implements getPeer operation.
//
// Retrieves data about the given peer.
//
// GET /eth/v1/node/peers/{peer_id}
func (UnimplementedHandler) GetPeer(ctx context.Context, params GetPeerParams) (r GetPeerRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPeerCount implements getPeerCount operation.
//
// Retrieves number of known peers.
//
// GET /eth/v1/node/peer_count
func (UnimplementedHandler) GetPeerCount(ctx context.Context) (r GetPeerCountRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPeers implements getPeers operation.
//
// Retrieves data about the node's network peers. By default this returns all peers. Multiple query
// params are combined using AND conditions.
//
// GET /eth/v1/node/peers
func (UnimplementedHandler) GetPeers(ctx context.Context, params GetPeersParams) (r GetPeersRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPoolAttestations implements getPoolAttestations operation.
//
// Retrieves attestations known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attestations
func (UnimplementedHandler) GetPoolAttestations(ctx context.Context, params GetPoolAttestationsParams) (r GetPoolAttestationsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPoolAttesterSlashings implements getPoolAttesterSlashings operation.
//
// Retrieves attester slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attester_slashings
func (UnimplementedHandler) GetPoolAttesterSlashings(ctx context.Context) (r GetPoolAttesterSlashingsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPoolBLSToExecutionChanges implements getPoolBLSToExecutionChanges operation.
//
// Retrieves BLS to execution changes known by the node but not necessarily incorporated into any
// block.
//
// GET /eth/v1/beacon/pool/bls_to_execution_changes
func (UnimplementedHandler) GetPoolBLSToExecutionChanges(ctx context.Context) (r GetPoolBLSToExecutionChangesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPoolProposerSlashings implements getPoolProposerSlashings operation.
//
// Retrieves proposer slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/proposer_slashings
func (UnimplementedHandler) GetPoolProposerSlashings(ctx context.Context) (r GetPoolProposerSlashingsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetPoolVoluntaryExits implements getPoolVoluntaryExits operation.
//
// Retrieves voluntary exits known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/voluntary_exits
func (UnimplementedHandler) GetPoolVoluntaryExits(ctx context.Context) (r GetPoolVoluntaryExitsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetProposerDuties implements getProposerDuties operation.
//
// Request beacon node to provide all validators that are scheduled to propose a block in the given
// epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization could occur
// that results in a change of duties. For full safety, you should monitor head events and confirm
// the dependent root in this response matches:
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) -
// 1)` or the genesis block root in the case of underflow.
//
// GET /eth/v1/validator/duties/proposer/{epoch}
func (UnimplementedHandler) GetProposerDuties(ctx context.Context, params GetProposerDutiesParams) (r GetProposerDutiesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetSpec implements getSpec operation.
//
// Retrieve specification configuration used on this node.  The configuration should include:
// - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and
// [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.
// md#constants) values
// - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values
// - Configuration for the beacon node, for example the [mainnet](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values
// Values are returned with following format:
// - any value starting with 0x in the spec is returned as a hex string
// - numeric values are returned as a quoted integer.
//
// GET /eth/v1/config/spec
func (UnimplementedHandler) GetSpec(ctx context.Context) (r GetSpecRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateFinalityCheckpoints implements getStateFinalityCheckpoints operation.
//
// Returns finality checkpoints for state with given 'stateId'.
// In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
//
// GET /eth/v1/beacon/states/{state_id}/finality_checkpoints
func (UnimplementedHandler) GetStateFinalityCheckpoints(ctx context.Context, params GetStateFinalityCheckpointsParams) (r GetStateFinalityCheckpointsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateFork implements getStateFork operation.
//
// Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.
// md#fork) object for state with given 'stateId'.
//
// GET /eth/v1/beacon/states/{state_id}/fork
func (UnimplementedHandler) GetStateFork(ctx context.Context, params GetStateForkParams) (r GetStateForkRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateRandao implements getStateRandao operation.
//
// Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.
// If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.
// By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix.
// Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are
// applied.
//
// GET /eth/v1/beacon/states/{state_id}/randao
func (UnimplementedHandler) GetStateRandao(ctx context.Context, params GetStateRandaoParams) (r GetStateRandaoRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateRoot implements getStateRoot operation.
//
// Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be
// returned.
//
// GET /eth/v1/beacon/states/{state_id}/root
func (UnimplementedHandler) GetStateRoot(ctx context.Context, params GetStateRootParams) (r GetStateRootRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateV2 implements getStateV2 operation.
//
// Returns full BeaconState object for given stateId.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/debug/beacon/states/{state_id}
func (UnimplementedHandler) GetStateV2(ctx context.Context, params GetStateV2Params) (r GetStateV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateValidator implements getStateValidator operation.
//
// Returns validator specified by state and id or public key along with status and balance.
//
// GET /eth/v1/beacon/states/{state_id}/validators/{validator_id}
func (UnimplementedHandler) GetStateValidator(ctx context.Context, params GetStateValidatorParams) (r GetStateValidatorRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateValidatorBalances implements getStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validator_balances
func (UnimplementedHandler) GetStateValidatorBalances(ctx context.Context, params GetStateValidatorBalancesParams) (r GetStateValidatorBalancesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetStateValidators implements getStateValidators operation.
//
// Returns filterable list of validators with their balance, status and index.
// Information will be returned for all indices or public key that match known validators.  If an
// index or public key does not
// match any known validator, no information will be returned but this will not cause an error.
// There are no guarantees for the
// returned data in terms of ordering; both the index and public key are returned for each validator,
// and can be used to confirm
// for which inputs a response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validators
func (UnimplementedHandler) GetStateValidators(ctx context.Context, params GetStateValidatorsParams) (r GetStateValidatorsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetSyncCommitteeDuties implements getSyncCommitteeDuties operation.
//
// Requests the beacon node to provide a set of sync committee duties for a particular epoch.
//
// POST /eth/v1/validator/duties/sync/{epoch}
func (UnimplementedHandler) GetSyncCommitteeDuties(ctx context.Context, req []string, params GetSyncCommitteeDutiesParams) (r GetSyncCommitteeDutiesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetSyncCommitteeRewards implements getSyncCommitteeRewards operation.
//
// Retrieves rewards info for sync committee members specified by array of public keys or validator
// index. If no array is provided, return reward info for every committee member.
//
// POST /eth/v1/beacon/rewards/sync_committee/{block_id}
func (UnimplementedHandler) GetSyncCommitteeRewards(ctx context.Context, req []string, params GetSyncCommitteeRewardsParams) (r GetSyncCommitteeRewardsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetSyncingStatus implements getSyncingStatus operation.
//
// Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it
// is up to.
//
// GET /eth/v1/node/syncing
func (UnimplementedHandler) GetSyncingStatus(ctx context.Context) (r GetSyncingStatusRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PostStateValidatorBalances implements postStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// POST /eth/v1/beacon/states/{state_id}/validator_balances
func (UnimplementedHandler) PostStateValidatorBalances(ctx context.Context, req []string, params PostStateValidatorBalancesParams) (r PostStateValidatorBalancesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PrepareBeaconCommitteeSubnet implements prepareBeaconCommitteeSubnet operation.
//
// After beacon node receives this request,
// search using discv5 for peers related to this subnet
// and replace current peers with those ones if necessary
// If validator `is_aggregator`, beacon node must:
// - announce subnet topic subscription on gossipsub
// - aggregate attestations received on that subnet.
//
// POST /eth/v1/validator/beacon_committee_subscriptions
func (UnimplementedHandler) PrepareBeaconCommitteeSubnet(ctx context.Context, req []PrepareBeaconCommitteeSubnetReqItem) (r PrepareBeaconCommitteeSubnetRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PrepareBeaconProposer implements prepareBeaconProposer operation.
//
// Prepares the beacon node for potential proposers by supplying information
// required when proposing blocks for the given validators.  The information
// supplied for each validator index will persist through the epoch in which
// the call is submitted and for a further two epochs after that, or until the
// beacon node restarts.  It is expected that validator clients will send this
// information periodically, for example each epoch, to ensure beacon nodes have
// correct and timely fee recipient information.
// Note that there is no guarantee that the beacon node will use the supplied fee
// recipient when creating a block proposal, so on receipt of a proposed block the
// validator should confirm that it finds the fee recipient within the block
// acceptable before signing it.
// Also note that requests containing currently inactive or unknown validator
// indices will be accepted, as they may become active at a later epoch.
//
// POST /eth/v1/validator/prepare_beacon_proposer
func (UnimplementedHandler) PrepareBeaconProposer(ctx context.Context, req []PrepareBeaconProposerReqItem) (r PrepareBeaconProposerRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PrepareSyncCommitteeSubnets implements prepareSyncCommitteeSubnets operation.
//
// Subscribe to a number of sync committee subnets
// Sync committees are not present in phase0, but are required for Altair networks.
// Subscribing to sync committee subnets is an action performed by VC to enable network participation
// in Altair networks, and only required if the VC has an active validator in an active sync
// committee.
//
// POST /eth/v1/validator/sync_committee_subscriptions
func (UnimplementedHandler) PrepareSyncCommitteeSubnets(ctx context.Context, req []PrepareSyncCommitteeSubnetsReqItem) (r PrepareSyncCommitteeSubnetsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ProduceAttestationData implements produceAttestationData operation.
//
// Requests that the beacon node produce an AttestationData.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the attestation attests to a block
// that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/attestation_data
func (UnimplementedHandler) ProduceAttestationData(ctx context.Context, params ProduceAttestationDataParams) (r ProduceAttestationDataRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ProduceBlindedBlock implements produceBlindedBlock operation.
//
// Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.
// A blinded block is a block with only a transactions root, rather than a full transactions list.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
// Before Bellatrix, this endpoint will return a `BeaconBlock`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v1/validator/blinded_blocks/{slot}
func (UnimplementedHandler) ProduceBlindedBlock(ctx context.Context, params ProduceBlindedBlockParams) (r ProduceBlindedBlockRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ProduceBlockV2 implements produceBlockV2 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v2/validator/blocks/{slot}
func (UnimplementedHandler) ProduceBlockV2(ctx context.Context, params ProduceBlockV2Params) (r ProduceBlockV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// ProduceBlockV3 implements produceBlockV3 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator. The
// returned block may be blinded or unblinded, depending on the current state of the network as
// decided by the execution and beacon nodes.
// The beacon node must return an unblinded block if it obtains the execution payload from its
// paired execution node. It must only return a blinded block if it obtains the execution payload
// header from an MEV relay.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// GET /eth/v3/validator/blocks/{slot}
func (UnimplementedHandler) ProduceBlockV3(ctx context.Context, params ProduceBlockV3Params) (r ProduceBlockV3Res, _ error) {
	return r, ht.ErrNotImplemented
}

// ProduceSyncCommitteeContribution implements produceSyncCommitteeContribution operation.
//
// Requests that the beacon node produce a sync committee contribution.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the sync committee contribution
// refers to a block that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/sync_committee_contribution
func (UnimplementedHandler) ProduceSyncCommitteeContribution(ctx context.Context, params ProduceSyncCommitteeContributionParams) (r ProduceSyncCommitteeContributionRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishAggregateAndProofs implements publishAggregateAndProofs operation.
//
// Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
//
// POST /eth/v1/validator/aggregate_and_proofs
func (UnimplementedHandler) PublishAggregateAndProofs(ctx context.Context, req []PublishAggregateAndProofsReqItem) (r PublishAggregateAndProofsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishBlindedBlock implements publishBlindedBlock operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`.
//
// POST /eth/v1/beacon/blinded_blocks
func (UnimplementedHandler) PublishBlindedBlock(ctx context.Context, req PublishBlindedBlockReqApplicationOctetStream, params PublishBlindedBlockParams) (r PublishBlindedBlockRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishBlindedBlockV2 implements publishBlindedBlockV2 operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation`
// query parameter.
//
// POST /eth/v2/beacon/blinded_blocks
func (UnimplementedHandler) PublishBlindedBlockV2(ctx context.Context, req PublishBlindedBlockV2ReqApplicationOctetStream, params PublishBlindedBlockV2Params) (r PublishBlindedBlockV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishBlock implements publishBlock operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs.
//
// POST /eth/v1/beacon/blocks
func (UnimplementedHandler) PublishBlock(ctx context.Context, req PublishBlockReqApplicationOctetStream, params PublishBlockParams) (r PublishBlockRes, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishBlockV2 implements publishBlockV2 operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into the state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the
// `broadcast_validation` query parameter.
//
// POST /eth/v2/beacon/blocks
func (UnimplementedHandler) PublishBlockV2(ctx context.Context, req PublishBlockV2ReqApplicationOctetStream, params PublishBlockV2Params) (r PublishBlockV2Res, _ error) {
	return r, ht.ErrNotImplemented
}

// PublishContributionAndProofs implements publishContributionAndProofs operation.
//
// Publish multiple signed sync committee contribution and proofs.
//
// POST /eth/v1/validator/contribution_and_proofs
func (UnimplementedHandler) PublishContributionAndProofs(ctx context.Context, req []PublishContributionAndProofsReqItem) (r PublishContributionAndProofsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// RegisterValidator implements registerValidator operation.
//
// Prepares the beacon node for engaging with external builders. The
// information must be sent by the beacon node to the builder network. It is
// expected that the validator client will send this information periodically
// to ensure the beacon node has correct and timely registration information
// to provide to builders. The validator client should not sign blinded beacon
// blocks that do not adhere to their latest fee recipient and gas limit
// preferences.
// Note that only registrations for active or pending validators must be sent to the builder network.
// Registrations for unknown or exited validators must be filtered out and not sent to the builder
// network.
//
// POST /eth/v1/validator/register_validator
func (UnimplementedHandler) RegisterValidator(ctx context.Context, req []RegisterValidatorReqItem) (r RegisterValidatorRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitBeaconCommitteeSelections implements submitBeaconCommitteeSelections operation.
//
// This endpoint should be used by a validator client running as part of a distributed validator
// cluster, and is
// implemented by a distributed validator middleware client. This endpoint is used to exchange partial
// selection proofs for combined/aggregated selection proofs to allow a validator client
// to correctly determine if any of its validators has been selected to perform an attestation
// aggregation duty in a slot.
// Validator clients running in a distributed validator cluster must query this endpoint at the start
// of an epoch for the current and lookahead (next) epochs for
// all validators that have attester duties in the current and lookahead epochs. Consensus clients
// need not support this
// endpoint and may return a 501.
//
// POST /eth/v1/validator/beacon_committee_selections
func (UnimplementedHandler) SubmitBeaconCommitteeSelections(ctx context.Context, req []SubmitBeaconCommitteeSelectionsReqItem) (r SubmitBeaconCommitteeSelectionsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolAttestations implements submitPoolAttestations operation.
//
// Submits Attestation objects to the node.  Each attestation in the request body is processed
// individually.
// If an attestation is validated successfully the node MUST publish that attestation on the
// appropriate subnet.
// If one or more attestations fail validation the node MUST return a 400 error with details of which
// attestations have failed, and why.
//
// POST /eth/v1/beacon/pool/attestations
func (UnimplementedHandler) SubmitPoolAttestations(ctx context.Context, req []SubmitPoolAttestationsReqItem) (r SubmitPoolAttestationsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolAttesterSlashings implements submitPoolAttesterSlashings operation.
//
// Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/attester_slashings
func (UnimplementedHandler) SubmitPoolAttesterSlashings(ctx context.Context, req *SubmitPoolAttesterSlashingsReq) (r SubmitPoolAttesterSlashingsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolBLSToExecutionChange implements submitPoolBLSToExecutionChange operation.
//
// Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST
// be broadcast to the network.
//
// POST /eth/v1/beacon/pool/bls_to_execution_changes
func (UnimplementedHandler) SubmitPoolBLSToExecutionChange(ctx context.Context, req []SubmitPoolBLSToExecutionChangeReqItem) (r SubmitPoolBLSToExecutionChangeRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolProposerSlashings implements submitPoolProposerSlashings operation.
//
// Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/proposer_slashings
func (UnimplementedHandler) SubmitPoolProposerSlashings(ctx context.Context, req *SubmitPoolProposerSlashingsReq) (r SubmitPoolProposerSlashingsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolSyncCommitteeSignatures implements submitPoolSyncCommitteeSignatures operation.
//
// Submits sync committee signature objects to the node.
// Sync committee signatures are not present in phase0, but are required for Altair networks.
// If a sync committee signature is validated successfully the node MUST publish that sync committee
// signature on all applicable subnets.
// If one or more sync committee signatures fail validation the node MUST return a 400 error with
// details of which sync committee signatures have failed, and why.
//
// POST /eth/v1/beacon/pool/sync_committees
func (UnimplementedHandler) SubmitPoolSyncCommitteeSignatures(ctx context.Context, req []SubmitPoolSyncCommitteeSignaturesReqItem) (r SubmitPoolSyncCommitteeSignaturesRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitPoolVoluntaryExit implements submitPoolVoluntaryExit operation.
//
// Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it
// to network.
//
// POST /eth/v1/beacon/pool/voluntary_exits
func (UnimplementedHandler) SubmitPoolVoluntaryExit(ctx context.Context, req *SubmitPoolVoluntaryExitReq) (r SubmitPoolVoluntaryExitRes, _ error) {
	return r, ht.ErrNotImplemented
}

// SubmitSyncCommitteeSelections implements submitSyncCommitteeSelections operation.
//
// Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated
// sync
// committee selection. This endpoint should be used by a validator client running as part of a
// distributed
// validator cluster, and is implemented by a distributed validator middleware client. This endpoint
// is
// used to exchange partial selection proofs (slot signatures) for combined/aggregated selection
// proofs to
// allow a validator client to correctly determine if any of its validators has been selected to
// perform a
// sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a
// distributed validator cluster must query this endpoint
// at the start of each slot for all validators that are included in the current sync committee.
// Consensus
// clients need not support this endpoint and may return a 501.
//
// POST /eth/v1/validator/sync_committee_selections
func (UnimplementedHandler) SubmitSyncCommitteeSelections(ctx context.Context, req []SubmitSyncCommitteeSelectionsReqItem) (r SubmitSyncCommitteeSelectionsRes, _ error) {
	return r, ht.ErrNotImplemented
}
