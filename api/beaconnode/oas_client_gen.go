// Code generated by ogen, DO NOT EDIT.

package beaconnode

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// Eventstream invokes eventstream operation.
	//
	// Provides endpoint to subscribe to beacon node Server-Sent-Events stream.
	// Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.
	// html#the-eventsource-interface)
	// implementation to listen on those events.
	// Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the
	// event stream connection alive in the presence of proxy servers.
	//
	// GET /eth/v1/events
	Eventstream(ctx context.Context, params EventstreamParams) (EventstreamRes, error)
	// GetAggregatedAttestation invokes getAggregatedAttestation operation.
	//
	// Aggregates all attestations matching given attestation data root and slot.
	// A 503 error must be returned if the block identified by the response
	// `beacon_block_root` is optimistic (i.e. the aggregated attestation attests
	// to a block that has not been fully verified by an execution engine).
	// A 404 error must be returned if no attestation is available for the requested
	// `attestation_data_root`.
	//
	// GET /eth/v1/validator/aggregate_attestation
	GetAggregatedAttestation(ctx context.Context, params GetAggregatedAttestationParams) (GetAggregatedAttestationRes, error)
	// GetAttestationsRewards invokes getAttestationsRewards operation.
	//
	// Retrieve attestation reward info for validators specified by array of public keys or validator
	// index. If no array is provided, return reward info for every validator.
	//
	// POST /eth/v1/beacon/rewards/attestations/{epoch}
	GetAttestationsRewards(ctx context.Context, request []string, params GetAttestationsRewardsParams) (GetAttestationsRewardsRes, error)
	// GetAttesterDuties invokes getAttesterDuties operation.
	//
	// Requests the beacon node to provide a set of attestation duties, which should be performed by
	// validators, for a particular epoch.
	// Duties should only need to be checked once per epoch, however a chain reorganization (of >
	// MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you
	// should monitor head events and confirm the dependent root in this response matches:
	// - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
	// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch`
	// - event.block otherwise
	// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1)
	// - 1)` or the genesis block root in the case of underflow.
	//
	// POST /eth/v1/validator/duties/attester/{epoch}
	GetAttesterDuties(ctx context.Context, request []string, params GetAttesterDutiesParams) (GetAttesterDutiesRes, error)
	// GetBlindedBlock invokes getBlindedBlock operation.
	//
	// Retrieves blinded block for given block ID.
	// Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ.
	//
	// GET /eth/v1/beacon/blinded_blocks/{block_id}
	GetBlindedBlock(ctx context.Context, params GetBlindedBlockParams) (GetBlindedBlockRes, error)
	// GetBlobSidecars invokes getBlobSidecars operation.
	//
	// Retrieves blob sidecars for a given block id.
	// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
	// If the `indices` parameter is specified, only the blob sidecars with the specified indices will be
	// returned. There are no guarantees
	// for the returned blob sidecars in terms of ordering.
	//
	// GET /eth/v1/beacon/blob_sidecars/{block_id}
	GetBlobSidecars(ctx context.Context, params GetBlobSidecarsParams) (GetBlobSidecarsRes, error)
	// GetBlockAttestations invokes getBlockAttestations operation.
	//
	// Retrieves attestation included in requested block.
	//
	// GET /eth/v1/beacon/blocks/{block_id}/attestations
	GetBlockAttestations(ctx context.Context, params GetBlockAttestationsParams) (GetBlockAttestationsRes, error)
	// GetBlockHeader invokes getBlockHeader operation.
	//
	// Retrieves block header for given block id.
	//
	// GET /eth/v1/beacon/headers/{block_id}
	GetBlockHeader(ctx context.Context, params GetBlockHeaderParams) (GetBlockHeaderRes, error)
	// GetBlockHeaders invokes getBlockHeaders operation.
	//
	// Retrieves block headers matching given query. By default it will fetch current head slot blocks.
	//
	// GET /eth/v1/beacon/headers
	GetBlockHeaders(ctx context.Context, params GetBlockHeadersParams) (GetBlockHeadersRes, error)
	// GetBlockRewards invokes getBlockRewards operation.
	//
	// Retrieve block reward info for a single block.
	//
	// GET /eth/v1/beacon/rewards/blocks/{block_id}
	GetBlockRewards(ctx context.Context, params GetBlockRewardsParams) (GetBlockRewardsRes, error)
	// GetBlockRoot invokes getBlockRoot operation.
	//
	// Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
	//
	// GET /eth/v1/beacon/blocks/{block_id}/root
	GetBlockRoot(ctx context.Context, params GetBlockRootParams) (GetBlockRootRes, error)
	// GetBlockV2 invokes getBlockV2 operation.
	//
	// Retrieves block details for given block id.
	// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
	//
	// GET /eth/v2/beacon/blocks/{block_id}
	GetBlockV2(ctx context.Context, params GetBlockV2Params) (GetBlockV2Res, error)
	// GetDebugChainHeadsV2 invokes getDebugChainHeadsV2 operation.
	//
	// Retrieves all possible chain heads (leaves of fork choice tree).
	//
	// GET /eth/v2/debug/beacon/heads
	GetDebugChainHeadsV2(ctx context.Context) (GetDebugChainHeadsV2Res, error)
	// GetDebugForkChoice invokes getDebugForkChoice operation.
	//
	// Retrieves all current fork choice context.
	//
	// GET /eth/v1/debug/fork_choice
	GetDebugForkChoice(ctx context.Context) (GetDebugForkChoiceRes, error)
	// GetDepositContract invokes getDepositContract operation.
	//
	// Retrieve Eth1 deposit contract address and chain ID.
	//
	// GET /eth/v1/config/deposit_contract
	GetDepositContract(ctx context.Context) (GetDepositContractRes, error)
	// GetDepositSnapshot invokes getDepositSnapshot operation.
	//
	// Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot.
	// Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ.
	//
	// GET /eth/v1/beacon/deposit_snapshot
	GetDepositSnapshot(ctx context.Context) (GetDepositSnapshotRes, error)
	// GetEpochCommittees invokes getEpochCommittees operation.
	//
	// Retrieves the committees for the given state.
	//
	// GET /eth/v1/beacon/states/{state_id}/committees
	GetEpochCommittees(ctx context.Context, params GetEpochCommitteesParams) (GetEpochCommitteesRes, error)
	// GetEpochSyncCommittees invokes getEpochSyncCommittees operation.
	//
	// Retrieves the current sync committee for the given state. Also returns the subcommittee
	// assignments.
	//
	// GET /eth/v1/beacon/states/{state_id}/sync_committees
	GetEpochSyncCommittees(ctx context.Context, params GetEpochSyncCommitteesParams) (GetEpochSyncCommitteesRes, error)
	// GetForkSchedule invokes getForkSchedule operation.
	//
	// Retrieve all forks, past present and future, of which this node is aware.
	//
	// GET /eth/v1/config/fork_schedule
	GetForkSchedule(ctx context.Context) (GetForkScheduleRes, error)
	// GetGenesis invokes getGenesis operation.
	//
	// Retrieve details of the chain's genesis which can be used to identify chain.
	//
	// GET /eth/v1/beacon/genesis
	GetGenesis(ctx context.Context) (GetGenesisRes, error)
	// GetHealth invokes getHealth operation.
	//
	// Returns node health status in http status codes. Useful for load balancers.
	//
	// GET /eth/v1/node/health
	GetHealth(ctx context.Context, params GetHealthParams) (GetHealthRes, error)
	// GetLightClientBootstrap invokes getLightClientBootstrap operation.
	//
	// Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.
	// 0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a
	// given post-Altair beacon block root.
	// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
	// Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
	// md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to
	// be known.
	//
	// GET /eth/v1/beacon/light_client/bootstrap/{block_root}
	GetLightClientBootstrap(ctx context.Context, params GetLightClientBootstrapParams) (GetLightClientBootstrapRes, error)
	// GetLightClientFinalityUpdate invokes getLightClientFinalityUpdate operation.
	//
	// Requests the latest [`LightClientFinalityUpdate`](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
	// md#lightclientfinalityupdate) known by the server.
	// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
	// Servers SHOULD provide results as defined in
	// [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
	// 0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
	//
	// GET /eth/v1/beacon/light_client/finality_update
	GetLightClientFinalityUpdate(ctx context.Context) (GetLightClientFinalityUpdateRes, error)
	// GetLightClientOptimisticUpdate invokes getLightClientOptimisticUpdate operation.
	//
	// Requests the latest [`LightClientOptimisticUpdate`](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
	// md#lightclientoptimisticupdate) known by the server.
	// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
	// Servers SHOULD provide results as defined in
	// [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
	// 0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
	//
	// GET /eth/v1/beacon/light_client/optimistic_update
	GetLightClientOptimisticUpdate(ctx context.Context) (GetLightClientOptimisticUpdateRes, error)
	// GetLightClientUpdatesByRange invokes getLightClientUpdatesByRange operation.
	//
	// Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.
	// 0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee
	// period range `[start_period, start_period + count)`, leading up to the current head sync committee
	// period as selected by fork choice.
	// Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.
	// Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
	// md#create_light_client_update). They MUST respond with at least the earliest known result within
	// the requested range, and MUST send results in consecutive order (by period). The response MUST NOT
	// contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration)
	// results.
	//
	// GET /eth/v1/beacon/light_client/updates
	GetLightClientUpdatesByRange(ctx context.Context, params GetLightClientUpdatesByRangeParams) (GetLightClientUpdatesByRangeRes, error)
	// GetLiveness invokes getLiveness operation.
	//
	// Requests the beacon node to indicate if a validator has been observed to be live in a given epoch.
	// The beacon node might detect liveness by observing messages from the validator on the network, in
	// the beacon chain, from its API or from any other source. A beacon node SHOULD support the current
	// and previous epoch, however it MAY support earlier epoch. It is important to note that the values
	// returned by the beacon node are not canonical; they are best-effort and based upon a subjective
	// view of the network. A beacon node that was recently started or suffered a network partition may
	// indicate that a validator is not live when it actually is.
	//
	// POST /eth/v1/validator/liveness/{epoch}
	GetLiveness(ctx context.Context, request []string, params GetLivenessParams) (GetLivenessRes, error)
	// GetNetworkIdentity invokes getNetworkIdentity operation.
	//
	// Retrieves data about the node's network presence.
	//
	// GET /eth/v1/node/identity
	GetNetworkIdentity(ctx context.Context) (GetNetworkIdentityRes, error)
	// GetNextWithdrawals invokes getNextWithdrawals operation.
	//
	// Get the withdrawals computed from the specified state, that will be included in the block
	// that gets built on the specified state.
	//
	// GET /eth/v1/builder/states/{state_id}/expected_withdrawals
	GetNextWithdrawals(ctx context.Context, params GetNextWithdrawalsParams) (GetNextWithdrawalsRes, error)
	// GetNodeVersion invokes getNodeVersion operation.
	//
	// Requests that the beacon node identify information about its implementation in a format similar to
	// a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
	//
	// GET /eth/v1/node/version
	GetNodeVersion(ctx context.Context) (GetNodeVersionRes, error)
	// GetPeer invokes getPeer operation.
	//
	// Retrieves data about the given peer.
	//
	// GET /eth/v1/node/peers/{peer_id}
	GetPeer(ctx context.Context, params GetPeerParams) (GetPeerRes, error)
	// GetPeerCount invokes getPeerCount operation.
	//
	// Retrieves number of known peers.
	//
	// GET /eth/v1/node/peer_count
	GetPeerCount(ctx context.Context) (GetPeerCountRes, error)
	// GetPeers invokes getPeers operation.
	//
	// Retrieves data about the node's network peers. By default this returns all peers. Multiple query
	// params are combined using AND conditions.
	//
	// GET /eth/v1/node/peers
	GetPeers(ctx context.Context, params GetPeersParams) (GetPeersRes, error)
	// GetPoolAttestations invokes getPoolAttestations operation.
	//
	// Retrieves attestations known by the node but not necessarily incorporated into any block.
	//
	// GET /eth/v1/beacon/pool/attestations
	GetPoolAttestations(ctx context.Context, params GetPoolAttestationsParams) (GetPoolAttestationsRes, error)
	// GetPoolAttesterSlashings invokes getPoolAttesterSlashings operation.
	//
	// Retrieves attester slashings known by the node but not necessarily incorporated into any block.
	//
	// GET /eth/v1/beacon/pool/attester_slashings
	GetPoolAttesterSlashings(ctx context.Context) (GetPoolAttesterSlashingsRes, error)
	// GetPoolBLSToExecutionChanges invokes getPoolBLSToExecutionChanges operation.
	//
	// Retrieves BLS to execution changes known by the node but not necessarily incorporated into any
	// block.
	//
	// GET /eth/v1/beacon/pool/bls_to_execution_changes
	GetPoolBLSToExecutionChanges(ctx context.Context) (GetPoolBLSToExecutionChangesRes, error)
	// GetPoolProposerSlashings invokes getPoolProposerSlashings operation.
	//
	// Retrieves proposer slashings known by the node but not necessarily incorporated into any block.
	//
	// GET /eth/v1/beacon/pool/proposer_slashings
	GetPoolProposerSlashings(ctx context.Context) (GetPoolProposerSlashingsRes, error)
	// GetPoolVoluntaryExits invokes getPoolVoluntaryExits operation.
	//
	// Retrieves voluntary exits known by the node but not necessarily incorporated into any block.
	//
	// GET /eth/v1/beacon/pool/voluntary_exits
	GetPoolVoluntaryExits(ctx context.Context) (GetPoolVoluntaryExitsRes, error)
	// GetProposerDuties invokes getProposerDuties operation.
	//
	// Request beacon node to provide all validators that are scheduled to propose a block in the given
	// epoch.
	// Duties should only need to be checked once per epoch, however a chain reorganization could occur
	// that results in a change of duties. For full safety, you should monitor head events and confirm
	// the dependent root in this response matches:
	// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
	// - event.block otherwise
	// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) -
	// 1)` or the genesis block root in the case of underflow.
	//
	// GET /eth/v1/validator/duties/proposer/{epoch}
	GetProposerDuties(ctx context.Context, params GetProposerDutiesParams) (GetProposerDutiesRes, error)
	// GetSpec invokes getSpec operation.
	//
	// Retrieve specification configuration used on this node.  The configuration should include:
	// - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and
	// [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.
	// md#constants) values
	// - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values
	// - Configuration for the beacon node, for example the [mainnet](https://github.
	// com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values
	// Values are returned with following format:
	// - any value starting with 0x in the spec is returned as a hex string
	// - numeric values are returned as a quoted integer.
	//
	// GET /eth/v1/config/spec
	GetSpec(ctx context.Context) (GetSpecRes, error)
	// GetStateFinalityCheckpoints invokes getStateFinalityCheckpoints operation.
	//
	// Returns finality checkpoints for state with given 'stateId'.
	// In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
	//
	// GET /eth/v1/beacon/states/{state_id}/finality_checkpoints
	GetStateFinalityCheckpoints(ctx context.Context, params GetStateFinalityCheckpointsParams) (GetStateFinalityCheckpointsRes, error)
	// GetStateFork invokes getStateFork operation.
	//
	// Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.
	// md#fork) object for state with given 'stateId'.
	//
	// GET /eth/v1/beacon/states/{state_id}/fork
	GetStateFork(ctx context.Context, params GetStateForkParams) (GetStateForkRes, error)
	// GetStateRandao invokes getStateRandao operation.
	//
	// Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.
	// If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.
	// By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix.
	// Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are
	// applied.
	//
	// GET /eth/v1/beacon/states/{state_id}/randao
	GetStateRandao(ctx context.Context, params GetStateRandaoParams) (GetStateRandaoRes, error)
	// GetStateRoot invokes getStateRoot operation.
	//
	// Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be
	// returned.
	//
	// GET /eth/v1/beacon/states/{state_id}/root
	GetStateRoot(ctx context.Context, params GetStateRootParams) (GetStateRootRes, error)
	// GetStateV2 invokes getStateV2 operation.
	//
	// Returns full BeaconState object for given stateId.
	// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
	//
	// GET /eth/v2/debug/beacon/states/{state_id}
	GetStateV2(ctx context.Context, params GetStateV2Params) (GetStateV2Res, error)
	// GetStateValidator invokes getStateValidator operation.
	//
	// Returns validator specified by state and id or public key along with status and balance.
	//
	// GET /eth/v1/beacon/states/{state_id}/validators/{validator_id}
	GetStateValidator(ctx context.Context, params GetStateValidatorParams) (GetStateValidatorRes, error)
	// GetStateValidatorBalances invokes getStateValidatorBalances operation.
	//
	// Returns filterable list of validators balances.
	// Balances will be returned for all indices or public key that match known validators. If an index
	// or public key does not
	// match any known validator, no balance will be returned but this will not cause an error. There are
	// no guarantees for the
	// returned data in terms of ordering; the index is returned for each balance, and can be used to
	// confirm for which inputs a
	// response has been returned.
	//
	// GET /eth/v1/beacon/states/{state_id}/validator_balances
	GetStateValidatorBalances(ctx context.Context, params GetStateValidatorBalancesParams) (GetStateValidatorBalancesRes, error)
	// GetStateValidators invokes getStateValidators operation.
	//
	// Returns filterable list of validators with their balance, status and index.
	// Information will be returned for all indices or public key that match known validators.  If an
	// index or public key does not
	// match any known validator, no information will be returned but this will not cause an error.
	// There are no guarantees for the
	// returned data in terms of ordering; both the index and public key are returned for each validator,
	// and can be used to confirm
	// for which inputs a response has been returned.
	//
	// GET /eth/v1/beacon/states/{state_id}/validators
	GetStateValidators(ctx context.Context, params GetStateValidatorsParams) (GetStateValidatorsRes, error)
	// GetSyncCommitteeDuties invokes getSyncCommitteeDuties operation.
	//
	// Requests the beacon node to provide a set of sync committee duties for a particular epoch.
	//
	// POST /eth/v1/validator/duties/sync/{epoch}
	GetSyncCommitteeDuties(ctx context.Context, request []string, params GetSyncCommitteeDutiesParams) (GetSyncCommitteeDutiesRes, error)
	// GetSyncCommitteeRewards invokes getSyncCommitteeRewards operation.
	//
	// Retrieves rewards info for sync committee members specified by array of public keys or validator
	// index. If no array is provided, return reward info for every committee member.
	//
	// POST /eth/v1/beacon/rewards/sync_committee/{block_id}
	GetSyncCommitteeRewards(ctx context.Context, request []string, params GetSyncCommitteeRewardsParams) (GetSyncCommitteeRewardsRes, error)
	// GetSyncingStatus invokes getSyncingStatus operation.
	//
	// Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it
	// is up to.
	//
	// GET /eth/v1/node/syncing
	GetSyncingStatus(ctx context.Context) (GetSyncingStatusRes, error)
	// PostStateValidatorBalances invokes postStateValidatorBalances operation.
	//
	// Returns filterable list of validators balances.
	// Balances will be returned for all indices or public key that match known validators. If an index
	// or public key does not
	// match any known validator, no balance will be returned but this will not cause an error. There are
	// no guarantees for the
	// returned data in terms of ordering; the index is returned for each balance, and can be used to
	// confirm for which inputs a
	// response has been returned.
	//
	// POST /eth/v1/beacon/states/{state_id}/validator_balances
	PostStateValidatorBalances(ctx context.Context, request []string, params PostStateValidatorBalancesParams) (PostStateValidatorBalancesRes, error)
	// PrepareBeaconCommitteeSubnet invokes prepareBeaconCommitteeSubnet operation.
	//
	// After beacon node receives this request,
	// search using discv5 for peers related to this subnet
	// and replace current peers with those ones if necessary
	// If validator `is_aggregator`, beacon node must:
	// - announce subnet topic subscription on gossipsub
	// - aggregate attestations received on that subnet.
	//
	// POST /eth/v1/validator/beacon_committee_subscriptions
	PrepareBeaconCommitteeSubnet(ctx context.Context, request []PrepareBeaconCommitteeSubnetReqItem) (PrepareBeaconCommitteeSubnetRes, error)
	// PrepareBeaconProposer invokes prepareBeaconProposer operation.
	//
	// Prepares the beacon node for potential proposers by supplying information
	// required when proposing blocks for the given validators.  The information
	// supplied for each validator index will persist through the epoch in which
	// the call is submitted and for a further two epochs after that, or until the
	// beacon node restarts.  It is expected that validator clients will send this
	// information periodically, for example each epoch, to ensure beacon nodes have
	// correct and timely fee recipient information.
	// Note that there is no guarantee that the beacon node will use the supplied fee
	// recipient when creating a block proposal, so on receipt of a proposed block the
	// validator should confirm that it finds the fee recipient within the block
	// acceptable before signing it.
	// Also note that requests containing currently inactive or unknown validator
	// indices will be accepted, as they may become active at a later epoch.
	//
	// POST /eth/v1/validator/prepare_beacon_proposer
	PrepareBeaconProposer(ctx context.Context, request []PrepareBeaconProposerReqItem) (PrepareBeaconProposerRes, error)
	// PrepareSyncCommitteeSubnets invokes prepareSyncCommitteeSubnets operation.
	//
	// Subscribe to a number of sync committee subnets
	// Sync committees are not present in phase0, but are required for Altair networks.
	// Subscribing to sync committee subnets is an action performed by VC to enable network participation
	// in Altair networks, and only required if the VC has an active validator in an active sync
	// committee.
	//
	// POST /eth/v1/validator/sync_committee_subscriptions
	PrepareSyncCommitteeSubnets(ctx context.Context, request []PrepareSyncCommitteeSubnetsReqItem) (PrepareSyncCommitteeSubnetsRes, error)
	// ProduceAttestationData invokes produceAttestationData operation.
	//
	// Requests that the beacon node produce an AttestationData.
	// A 503 error must be returned if the block identified by the response
	// `beacon_block_root` is optimistic (i.e. the attestation attests to a block
	// that has not been fully verified by an execution engine).
	//
	// GET /eth/v1/validator/attestation_data
	ProduceAttestationData(ctx context.Context, params ProduceAttestationDataParams) (ProduceAttestationDataRes, error)
	// ProduceBlindedBlock invokes produceBlindedBlock operation.
	//
	// Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.
	// A blinded block is a block with only a transactions root, rather than a full transactions list.
	// Metadata in the response indicates the type of block produced, and the supported types of block
	// will be added to as forks progress.
	// Before Bellatrix, this endpoint will return a `BeaconBlock`.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /eth/v1/validator/blinded_blocks/{slot}
	ProduceBlindedBlock(ctx context.Context, params ProduceBlindedBlockParams) (ProduceBlindedBlockRes, error)
	// ProduceBlockV2 invokes produceBlockV2 operation.
	//
	// Requests a beacon node to produce a valid block, which can then be signed by a validator.
	// Metadata in the response indicates the type of block produced, and the supported types of block
	// will be added to as forks progress.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /eth/v2/validator/blocks/{slot}
	ProduceBlockV2(ctx context.Context, params ProduceBlockV2Params) (ProduceBlockV2Res, error)
	// ProduceBlockV3 invokes produceBlockV3 operation.
	//
	// Requests a beacon node to produce a valid block, which can then be signed by a validator. The
	// returned block may be blinded or unblinded, depending on the current state of the network as
	// decided by the execution and beacon nodes.
	// The beacon node must return an unblinded block if it obtains the execution payload from its
	// paired execution node. It must only return a blinded block if it obtains the execution payload
	// header from an MEV relay.
	// Metadata in the response indicates the type of block produced, and the supported types of block
	// will be added to as forks progress.
	//
	// GET /eth/v3/validator/blocks/{slot}
	ProduceBlockV3(ctx context.Context, params ProduceBlockV3Params) (ProduceBlockV3Res, error)
	// ProduceSyncCommitteeContribution invokes produceSyncCommitteeContribution operation.
	//
	// Requests that the beacon node produce a sync committee contribution.
	// A 503 error must be returned if the block identified by the response
	// `beacon_block_root` is optimistic (i.e. the sync committee contribution
	// refers to a block that has not been fully verified by an execution engine).
	//
	// GET /eth/v1/validator/sync_committee_contribution
	ProduceSyncCommitteeContribution(ctx context.Context, params ProduceSyncCommitteeContributionParams) (ProduceSyncCommitteeContributionRes, error)
	// PublishAggregateAndProofs invokes publishAggregateAndProofs operation.
	//
	// Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
	//
	// POST /eth/v1/validator/aggregate_and_proofs
	PublishAggregateAndProofs(ctx context.Context, request []PublishAggregateAndProofsReqItem) (PublishAggregateAndProofsRes, error)
	// PublishBlindedBlock invokes publishBlindedBlock operation.
	//
	// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
	// publish a
	// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
	// `transactions`.
	// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
	// to be included in the beacon chain. The beacon node is not required to validate the signed
	// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
	// successful. The beacon node is expected to integrate the new block into its state, and
	// therefore validate the block internally, however blocks which fail the validation are still
	// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
	// accept
	// a `SignedBeaconBlock`.
	//
	// POST /eth/v1/beacon/blinded_blocks
	PublishBlindedBlock(ctx context.Context, request PublishBlindedBlockReqApplicationOctetStream, params PublishBlindedBlockParams) (PublishBlindedBlockRes, error)
	// PublishBlindedBlockV2 invokes publishBlindedBlockV2 operation.
	//
	// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
	// publish a
	// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
	// `transactions`.
	// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
	// to be included in the beacon chain. The beacon node is not required to validate the signed
	// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
	// successful. The beacon node is expected to integrate the new block into its state, and
	// therefore validate the block internally, however blocks which fail the validation are still
	// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
	// accept
	// a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation`
	// query parameter.
	//
	// POST /eth/v2/beacon/blinded_blocks
	PublishBlindedBlockV2(ctx context.Context, request PublishBlindedBlockV2ReqApplicationOctetStream, params PublishBlindedBlockV2Params) (PublishBlindedBlockV2Res, error)
	// PublishBlock invokes publishBlock operation.
	//
	// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
	// to be included in the beacon chain. A success response (20x) indicates that the block
	// passed gossip validation and was successfully broadcast onto the network.
	// The beacon node is also expected to integrate the block into state, but may broadcast it
	// before doing so, so as to aid timely delivery of the block. Should the block fail full
	// validation, a separate success response code (202) is used to indicate that the block was
	// successfully broadcast but failed integration. After Deneb, this additionally instructs
	// the beacon node to broadcast all given blobs.
	//
	// POST /eth/v1/beacon/blocks
	PublishBlock(ctx context.Context, request PublishBlockReqApplicationOctetStream, params PublishBlockParams) (PublishBlockRes, error)
	// PublishBlockV2 invokes publishBlockV2 operation.
	//
	// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
	// to be included in the beacon chain. A success response (20x) indicates that the block
	// passed gossip validation and was successfully broadcast onto the network.
	// The beacon node is also expected to integrate the block into the state, but may broadcast it
	// before doing so, so as to aid timely delivery of the block. Should the block fail full
	// validation, a separate success response code (202) is used to indicate that the block was
	// successfully broadcast but failed integration. After Deneb, this additionally instructs
	// the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the
	// `broadcast_validation` query parameter.
	//
	// POST /eth/v2/beacon/blocks
	PublishBlockV2(ctx context.Context, request PublishBlockV2ReqApplicationOctetStream, params PublishBlockV2Params) (PublishBlockV2Res, error)
	// PublishContributionAndProofs invokes publishContributionAndProofs operation.
	//
	// Publish multiple signed sync committee contribution and proofs.
	//
	// POST /eth/v1/validator/contribution_and_proofs
	PublishContributionAndProofs(ctx context.Context, request []PublishContributionAndProofsReqItem) (PublishContributionAndProofsRes, error)
	// RegisterValidator invokes registerValidator operation.
	//
	// Prepares the beacon node for engaging with external builders. The
	// information must be sent by the beacon node to the builder network. It is
	// expected that the validator client will send this information periodically
	// to ensure the beacon node has correct and timely registration information
	// to provide to builders. The validator client should not sign blinded beacon
	// blocks that do not adhere to their latest fee recipient and gas limit
	// preferences.
	// Note that only registrations for active or pending validators must be sent to the builder network.
	// Registrations for unknown or exited validators must be filtered out and not sent to the builder
	// network.
	//
	// POST /eth/v1/validator/register_validator
	RegisterValidator(ctx context.Context, request []RegisterValidatorReqItem) (RegisterValidatorRes, error)
	// SubmitBeaconCommitteeSelections invokes submitBeaconCommitteeSelections operation.
	//
	// This endpoint should be used by a validator client running as part of a distributed validator
	// cluster, and is
	// implemented by a distributed validator middleware client. This endpoint is used to exchange partial
	// selection proofs for combined/aggregated selection proofs to allow a validator client
	// to correctly determine if any of its validators has been selected to perform an attestation
	// aggregation duty in a slot.
	// Validator clients running in a distributed validator cluster must query this endpoint at the start
	// of an epoch for the current and lookahead (next) epochs for
	// all validators that have attester duties in the current and lookahead epochs. Consensus clients
	// need not support this
	// endpoint and may return a 501.
	//
	// POST /eth/v1/validator/beacon_committee_selections
	SubmitBeaconCommitteeSelections(ctx context.Context, request []SubmitBeaconCommitteeSelectionsReqItem) (SubmitBeaconCommitteeSelectionsRes, error)
	// SubmitPoolAttestations invokes submitPoolAttestations operation.
	//
	// Submits Attestation objects to the node.  Each attestation in the request body is processed
	// individually.
	// If an attestation is validated successfully the node MUST publish that attestation on the
	// appropriate subnet.
	// If one or more attestations fail validation the node MUST return a 400 error with details of which
	// attestations have failed, and why.
	//
	// POST /eth/v1/beacon/pool/attestations
	SubmitPoolAttestations(ctx context.Context, request []SubmitPoolAttestationsReqItem) (SubmitPoolAttestationsRes, error)
	// SubmitPoolAttesterSlashings invokes submitPoolAttesterSlashings operation.
	//
	// Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to
	// network.
	//
	// POST /eth/v1/beacon/pool/attester_slashings
	SubmitPoolAttesterSlashings(ctx context.Context, request *SubmitPoolAttesterSlashingsReq) (SubmitPoolAttesterSlashingsRes, error)
	// SubmitPoolBLSToExecutionChange invokes submitPoolBLSToExecutionChange operation.
	//
	// Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST
	// be broadcast to the network.
	//
	// POST /eth/v1/beacon/pool/bls_to_execution_changes
	SubmitPoolBLSToExecutionChange(ctx context.Context, request []SubmitPoolBLSToExecutionChangeReqItem) (SubmitPoolBLSToExecutionChangeRes, error)
	// SubmitPoolProposerSlashings invokes submitPoolProposerSlashings operation.
	//
	// Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to
	// network.
	//
	// POST /eth/v1/beacon/pool/proposer_slashings
	SubmitPoolProposerSlashings(ctx context.Context, request *SubmitPoolProposerSlashingsReq) (SubmitPoolProposerSlashingsRes, error)
	// SubmitPoolSyncCommitteeSignatures invokes submitPoolSyncCommitteeSignatures operation.
	//
	// Submits sync committee signature objects to the node.
	// Sync committee signatures are not present in phase0, but are required for Altair networks.
	// If a sync committee signature is validated successfully the node MUST publish that sync committee
	// signature on all applicable subnets.
	// If one or more sync committee signatures fail validation the node MUST return a 400 error with
	// details of which sync committee signatures have failed, and why.
	//
	// POST /eth/v1/beacon/pool/sync_committees
	SubmitPoolSyncCommitteeSignatures(ctx context.Context, request []SubmitPoolSyncCommitteeSignaturesReqItem) (SubmitPoolSyncCommitteeSignaturesRes, error)
	// SubmitPoolVoluntaryExit invokes submitPoolVoluntaryExit operation.
	//
	// Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it
	// to network.
	//
	// POST /eth/v1/beacon/pool/voluntary_exits
	SubmitPoolVoluntaryExit(ctx context.Context, request *SubmitPoolVoluntaryExitReq) (SubmitPoolVoluntaryExitRes, error)
	// SubmitSyncCommitteeSelections invokes submitSyncCommitteeSelections operation.
	//
	// Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated
	// sync
	// committee selection. This endpoint should be used by a validator client running as part of a
	// distributed
	// validator cluster, and is implemented by a distributed validator middleware client. This endpoint
	// is
	// used to exchange partial selection proofs (slot signatures) for combined/aggregated selection
	// proofs to
	// allow a validator client to correctly determine if any of its validators has been selected to
	// perform a
	// sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a
	// distributed validator cluster must query this endpoint
	// at the start of each slot for all validators that are included in the current sync committee.
	// Consensus
	// clients need not support this endpoint and may return a 501.
	//
	// POST /eth/v1/validator/sync_committee_selections
	SubmitSyncCommitteeSelections(ctx context.Context, request []SubmitSyncCommitteeSelectionsReqItem) (SubmitSyncCommitteeSelectionsRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// Eventstream invokes eventstream operation.
//
// Provides endpoint to subscribe to beacon node Server-Sent-Events stream.
// Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.
// html#the-eventsource-interface)
// implementation to listen on those events.
// Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the
// event stream connection alive in the presence of proxy servers.
//
// GET /eth/v1/events
func (c *Client) Eventstream(ctx context.Context, params EventstreamParams) (EventstreamRes, error) {
	res, err := c.sendEventstream(ctx, params)
	return res, err
}

func (c *Client) sendEventstream(ctx context.Context, params EventstreamParams) (res EventstreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("eventstream"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Eventstream",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "topics" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "topics",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Topics {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEventstreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAggregatedAttestation invokes getAggregatedAttestation operation.
//
// Aggregates all attestations matching given attestation data root and slot.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the aggregated attestation attests
// to a block that has not been fully verified by an execution engine).
// A 404 error must be returned if no attestation is available for the requested
// `attestation_data_root`.
//
// GET /eth/v1/validator/aggregate_attestation
func (c *Client) GetAggregatedAttestation(ctx context.Context, params GetAggregatedAttestationParams) (GetAggregatedAttestationRes, error) {
	res, err := c.sendGetAggregatedAttestation(ctx, params)
	return res, err
}

func (c *Client) sendGetAggregatedAttestation(ctx context.Context, params GetAggregatedAttestationParams) (res GetAggregatedAttestationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAggregatedAttestation"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/aggregate_attestation"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAggregatedAttestation",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/aggregate_attestation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "attestation_data_root" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "attestation_data_root",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AttestationDataRoot))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAggregatedAttestationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAttestationsRewards invokes getAttestationsRewards operation.
//
// Retrieve attestation reward info for validators specified by array of public keys or validator
// index. If no array is provided, return reward info for every validator.
//
// POST /eth/v1/beacon/rewards/attestations/{epoch}
func (c *Client) GetAttestationsRewards(ctx context.Context, request []string, params GetAttestationsRewardsParams) (GetAttestationsRewardsRes, error) {
	res, err := c.sendGetAttestationsRewards(ctx, request, params)
	return res, err
}

func (c *Client) sendGetAttestationsRewards(ctx context.Context, request []string, params GetAttestationsRewardsParams) (res GetAttestationsRewardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttestationsRewards"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/attestations/{epoch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAttestationsRewards",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/rewards/attestations/"
	{
		// Encode "epoch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "epoch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Epoch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetAttestationsRewardsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAttestationsRewardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAttesterDuties invokes getAttesterDuties operation.
//
// Requests the beacon node to provide a set of attestation duties, which should be performed by
// validators, for a particular epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization (of >
// MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you
// should monitor head events and confirm the dependent root in this response matches:
// - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1)
// - 1)` or the genesis block root in the case of underflow.
//
// POST /eth/v1/validator/duties/attester/{epoch}
func (c *Client) GetAttesterDuties(ctx context.Context, request []string, params GetAttesterDutiesParams) (GetAttesterDutiesRes, error) {
	res, err := c.sendGetAttesterDuties(ctx, request, params)
	return res, err
}

func (c *Client) sendGetAttesterDuties(ctx context.Context, request []string, params GetAttesterDutiesParams) (res GetAttesterDutiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttesterDuties"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/attester/{epoch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAttesterDuties",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/validator/duties/attester/"
	{
		// Encode "epoch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "epoch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Epoch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetAttesterDutiesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAttesterDutiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlindedBlock invokes getBlindedBlock operation.
//
// Retrieves blinded block for given block ID.
// Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ.
//
// GET /eth/v1/beacon/blinded_blocks/{block_id}
func (c *Client) GetBlindedBlock(ctx context.Context, params GetBlindedBlockParams) (GetBlindedBlockRes, error) {
	res, err := c.sendGetBlindedBlock(ctx, params)
	return res, err
}

func (c *Client) sendGetBlindedBlock(ctx context.Context, params GetBlindedBlockParams) (res GetBlindedBlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlindedBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blinded_blocks/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/blinded_blocks/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlindedBlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlobSidecars invokes getBlobSidecars operation.
//
// Retrieves blob sidecars for a given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
// If the `indices` parameter is specified, only the blob sidecars with the specified indices will be
// returned. There are no guarantees
// for the returned blob sidecars in terms of ordering.
//
// GET /eth/v1/beacon/blob_sidecars/{block_id}
func (c *Client) GetBlobSidecars(ctx context.Context, params GetBlobSidecarsParams) (GetBlobSidecarsRes, error) {
	res, err := c.sendGetBlobSidecars(ctx, params)
	return res, err
}

func (c *Client) sendGetBlobSidecars(ctx context.Context, params GetBlobSidecarsParams) (res GetBlobSidecarsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlobSidecars"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blob_sidecars/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlobSidecars",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/blob_sidecars/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "indices" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "indices",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Indices {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlobSidecarsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockAttestations invokes getBlockAttestations operation.
//
// Retrieves attestation included in requested block.
//
// GET /eth/v1/beacon/blocks/{block_id}/attestations
func (c *Client) GetBlockAttestations(ctx context.Context, params GetBlockAttestationsParams) (GetBlockAttestationsRes, error) {
	res, err := c.sendGetBlockAttestations(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockAttestations(ctx context.Context, params GetBlockAttestationsParams) (res GetBlockAttestationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockAttestations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks/{block_id}/attestations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockAttestations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/blocks/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/attestations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockAttestationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockHeader invokes getBlockHeader operation.
//
// Retrieves block header for given block id.
//
// GET /eth/v1/beacon/headers/{block_id}
func (c *Client) GetBlockHeader(ctx context.Context, params GetBlockHeaderParams) (GetBlockHeaderRes, error) {
	res, err := c.sendGetBlockHeader(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockHeader(ctx context.Context, params GetBlockHeaderParams) (res GetBlockHeaderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockHeader"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/headers/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockHeader",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/headers/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockHeaderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockHeaders invokes getBlockHeaders operation.
//
// Retrieves block headers matching given query. By default it will fetch current head slot blocks.
//
// GET /eth/v1/beacon/headers
func (c *Client) GetBlockHeaders(ctx context.Context, params GetBlockHeadersParams) (GetBlockHeadersRes, error) {
	res, err := c.sendGetBlockHeaders(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockHeaders(ctx context.Context, params GetBlockHeadersParams) (res GetBlockHeadersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockHeaders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/headers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockHeaders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/headers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Slot.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "parent_root" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "parent_root",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParentRoot.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockHeadersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockRewards invokes getBlockRewards operation.
//
// Retrieve block reward info for a single block.
//
// GET /eth/v1/beacon/rewards/blocks/{block_id}
func (c *Client) GetBlockRewards(ctx context.Context, params GetBlockRewardsParams) (GetBlockRewardsRes, error) {
	res, err := c.sendGetBlockRewards(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockRewards(ctx context.Context, params GetBlockRewardsParams) (res GetBlockRewardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockRewards"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/blocks/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockRewards",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/rewards/blocks/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockRewardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockRoot invokes getBlockRoot operation.
//
// Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
//
// GET /eth/v1/beacon/blocks/{block_id}/root
func (c *Client) GetBlockRoot(ctx context.Context, params GetBlockRootParams) (GetBlockRootRes, error) {
	res, err := c.sendGetBlockRoot(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockRoot(ctx context.Context, params GetBlockRootParams) (res GetBlockRootRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockRoot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks/{block_id}/root"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockRoot",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/blocks/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/root"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockRootResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBlockV2 invokes getBlockV2 operation.
//
// Retrieves block details for given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/beacon/blocks/{block_id}
func (c *Client) GetBlockV2(ctx context.Context, params GetBlockV2Params) (GetBlockV2Res, error) {
	res, err := c.sendGetBlockV2(ctx, params)
	return res, err
}

func (c *Client) sendGetBlockV2(ctx context.Context, params GetBlockV2Params) (res GetBlockV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blocks/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBlockV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v2/beacon/blocks/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBlockV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDebugChainHeadsV2 invokes getDebugChainHeadsV2 operation.
//
// Retrieves all possible chain heads (leaves of fork choice tree).
//
// GET /eth/v2/debug/beacon/heads
func (c *Client) GetDebugChainHeadsV2(ctx context.Context) (GetDebugChainHeadsV2Res, error) {
	res, err := c.sendGetDebugChainHeadsV2(ctx)
	return res, err
}

func (c *Client) sendGetDebugChainHeadsV2(ctx context.Context) (res GetDebugChainHeadsV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDebugChainHeadsV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/debug/beacon/heads"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDebugChainHeadsV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v2/debug/beacon/heads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDebugChainHeadsV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDebugForkChoice invokes getDebugForkChoice operation.
//
// Retrieves all current fork choice context.
//
// GET /eth/v1/debug/fork_choice
func (c *Client) GetDebugForkChoice(ctx context.Context) (GetDebugForkChoiceRes, error) {
	res, err := c.sendGetDebugForkChoice(ctx)
	return res, err
}

func (c *Client) sendGetDebugForkChoice(ctx context.Context) (res GetDebugForkChoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDebugForkChoice"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/debug/fork_choice"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDebugForkChoice",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/debug/fork_choice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDebugForkChoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDepositContract invokes getDepositContract operation.
//
// Retrieve Eth1 deposit contract address and chain ID.
//
// GET /eth/v1/config/deposit_contract
func (c *Client) GetDepositContract(ctx context.Context) (GetDepositContractRes, error) {
	res, err := c.sendGetDepositContract(ctx)
	return res, err
}

func (c *Client) sendGetDepositContract(ctx context.Context) (res GetDepositContractRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDepositContract"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/deposit_contract"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDepositContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/config/deposit_contract"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDepositContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDepositSnapshot invokes getDepositSnapshot operation.
//
// Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot.
// Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ.
//
// GET /eth/v1/beacon/deposit_snapshot
func (c *Client) GetDepositSnapshot(ctx context.Context) (GetDepositSnapshotRes, error) {
	res, err := c.sendGetDepositSnapshot(ctx)
	return res, err
}

func (c *Client) sendGetDepositSnapshot(ctx context.Context) (res GetDepositSnapshotRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDepositSnapshot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/deposit_snapshot"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetDepositSnapshot",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/deposit_snapshot"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDepositSnapshotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEpochCommittees invokes getEpochCommittees operation.
//
// Retrieves the committees for the given state.
//
// GET /eth/v1/beacon/states/{state_id}/committees
func (c *Client) GetEpochCommittees(ctx context.Context, params GetEpochCommitteesParams) (GetEpochCommitteesRes, error) {
	res, err := c.sendGetEpochCommittees(ctx, params)
	return res, err
}

func (c *Client) sendGetEpochCommittees(ctx context.Context, params GetEpochCommitteesParams) (res GetEpochCommitteesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEpochCommittees"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/committees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetEpochCommittees",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/committees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "epoch" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "epoch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Epoch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "index" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "index",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Index.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Slot.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEpochCommitteesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEpochSyncCommittees invokes getEpochSyncCommittees operation.
//
// Retrieves the current sync committee for the given state. Also returns the subcommittee
// assignments.
//
// GET /eth/v1/beacon/states/{state_id}/sync_committees
func (c *Client) GetEpochSyncCommittees(ctx context.Context, params GetEpochSyncCommitteesParams) (GetEpochSyncCommitteesRes, error) {
	res, err := c.sendGetEpochSyncCommittees(ctx, params)
	return res, err
}

func (c *Client) sendGetEpochSyncCommittees(ctx context.Context, params GetEpochSyncCommitteesParams) (res GetEpochSyncCommitteesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEpochSyncCommittees"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/sync_committees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetEpochSyncCommittees",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sync_committees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "epoch" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "epoch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Epoch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEpochSyncCommitteesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetForkSchedule invokes getForkSchedule operation.
//
// Retrieve all forks, past present and future, of which this node is aware.
//
// GET /eth/v1/config/fork_schedule
func (c *Client) GetForkSchedule(ctx context.Context) (GetForkScheduleRes, error) {
	res, err := c.sendGetForkSchedule(ctx)
	return res, err
}

func (c *Client) sendGetForkSchedule(ctx context.Context) (res GetForkScheduleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getForkSchedule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/fork_schedule"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetForkSchedule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/config/fork_schedule"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetForkScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGenesis invokes getGenesis operation.
//
// Retrieve details of the chain's genesis which can be used to identify chain.
//
// GET /eth/v1/beacon/genesis
func (c *Client) GetGenesis(ctx context.Context) (GetGenesisRes, error) {
	res, err := c.sendGetGenesis(ctx)
	return res, err
}

func (c *Client) sendGetGenesis(ctx context.Context) (res GetGenesisRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGenesis"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/genesis"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGenesis",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/genesis"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGenesisResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHealth invokes getHealth operation.
//
// Returns node health status in http status codes. Useful for load balancers.
//
// GET /eth/v1/node/health
func (c *Client) GetHealth(ctx context.Context, params GetHealthParams) (GetHealthRes, error) {
	res, err := c.sendGetHealth(ctx, params)
	return res, err
}

func (c *Client) sendGetHealth(ctx context.Context, params GetHealthParams) (res GetHealthRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getHealth"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/health"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetHealth",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "syncing_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "syncing_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SyncingStatus.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLightClientBootstrap invokes getLightClientBootstrap operation.
//
// Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a
// given post-Altair beacon block root.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to
// be known.
//
// GET /eth/v1/beacon/light_client/bootstrap/{block_root}
func (c *Client) GetLightClientBootstrap(ctx context.Context, params GetLightClientBootstrapParams) (GetLightClientBootstrapRes, error) {
	res, err := c.sendGetLightClientBootstrap(ctx, params)
	return res, err
}

func (c *Client) sendGetLightClientBootstrap(ctx context.Context, params GetLightClientBootstrapParams) (res GetLightClientBootstrapRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientBootstrap"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/bootstrap/{block_root}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLightClientBootstrap",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/light_client/bootstrap/"
	{
		// Encode "block_root" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_root",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockRoot))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLightClientBootstrapResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLightClientFinalityUpdate invokes getLightClientFinalityUpdate operation.
//
// Requests the latest [`LightClientFinalityUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientfinalityupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
//
// GET /eth/v1/beacon/light_client/finality_update
func (c *Client) GetLightClientFinalityUpdate(ctx context.Context) (GetLightClientFinalityUpdateRes, error) {
	res, err := c.sendGetLightClientFinalityUpdate(ctx)
	return res, err
}

func (c *Client) sendGetLightClientFinalityUpdate(ctx context.Context) (res GetLightClientFinalityUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientFinalityUpdate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/finality_update"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLightClientFinalityUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/light_client/finality_update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLightClientFinalityUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLightClientOptimisticUpdate invokes getLightClientOptimisticUpdate operation.
//
// Requests the latest [`LightClientOptimisticUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientoptimisticupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
//
// GET /eth/v1/beacon/light_client/optimistic_update
func (c *Client) GetLightClientOptimisticUpdate(ctx context.Context) (GetLightClientOptimisticUpdateRes, error) {
	res, err := c.sendGetLightClientOptimisticUpdate(ctx)
	return res, err
}

func (c *Client) sendGetLightClientOptimisticUpdate(ctx context.Context) (res GetLightClientOptimisticUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientOptimisticUpdate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/optimistic_update"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLightClientOptimisticUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/light_client/optimistic_update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLightClientOptimisticUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLightClientUpdatesByRange invokes getLightClientUpdatesByRange operation.
//
// Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee
// period range `[start_period, start_period + count)`, leading up to the current head sync committee
// period as selected by fork choice.
// Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_update). They MUST respond with at least the earliest known result within
// the requested range, and MUST send results in consecutive order (by period). The response MUST NOT
// contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration)
// results.
//
// GET /eth/v1/beacon/light_client/updates
func (c *Client) GetLightClientUpdatesByRange(ctx context.Context, params GetLightClientUpdatesByRangeParams) (GetLightClientUpdatesByRangeRes, error) {
	res, err := c.sendGetLightClientUpdatesByRange(ctx, params)
	return res, err
}

func (c *Client) sendGetLightClientUpdatesByRange(ctx context.Context, params GetLightClientUpdatesByRangeParams) (res GetLightClientUpdatesByRangeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientUpdatesByRange"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/updates"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLightClientUpdatesByRange",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/light_client/updates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_period" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_period",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.StartPeriod))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLightClientUpdatesByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLiveness invokes getLiveness operation.
//
// Requests the beacon node to indicate if a validator has been observed to be live in a given epoch.
// The beacon node might detect liveness by observing messages from the validator on the network, in
// the beacon chain, from its API or from any other source. A beacon node SHOULD support the current
// and previous epoch, however it MAY support earlier epoch. It is important to note that the values
// returned by the beacon node are not canonical; they are best-effort and based upon a subjective
// view of the network. A beacon node that was recently started or suffered a network partition may
// indicate that a validator is not live when it actually is.
//
// POST /eth/v1/validator/liveness/{epoch}
func (c *Client) GetLiveness(ctx context.Context, request []string, params GetLivenessParams) (GetLivenessRes, error) {
	res, err := c.sendGetLiveness(ctx, request, params)
	return res, err
}

func (c *Client) sendGetLiveness(ctx context.Context, request []string, params GetLivenessParams) (res GetLivenessRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLiveness"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/liveness/{epoch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetLiveness",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/validator/liveness/"
	{
		// Encode "epoch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "epoch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Epoch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetLivenessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLivenessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworkIdentity invokes getNetworkIdentity operation.
//
// Retrieves data about the node's network presence.
//
// GET /eth/v1/node/identity
func (c *Client) GetNetworkIdentity(ctx context.Context) (GetNetworkIdentityRes, error) {
	res, err := c.sendGetNetworkIdentity(ctx)
	return res, err
}

func (c *Client) sendGetNetworkIdentity(ctx context.Context) (res GetNetworkIdentityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkIdentity"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/identity"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetNetworkIdentity",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/identity"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetNetworkIdentityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNextWithdrawals invokes getNextWithdrawals operation.
//
// Get the withdrawals computed from the specified state, that will be included in the block
// that gets built on the specified state.
//
// GET /eth/v1/builder/states/{state_id}/expected_withdrawals
func (c *Client) GetNextWithdrawals(ctx context.Context, params GetNextWithdrawalsParams) (GetNextWithdrawalsRes, error) {
	res, err := c.sendGetNextWithdrawals(ctx, params)
	return res, err
}

func (c *Client) sendGetNextWithdrawals(ctx context.Context, params GetNextWithdrawalsParams) (res GetNextWithdrawalsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNextWithdrawals"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/builder/states/{state_id}/expected_withdrawals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetNextWithdrawals",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/builder/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/expected_withdrawals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "proposal_slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "proposal_slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProposalSlot.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetNextWithdrawalsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNodeVersion invokes getNodeVersion operation.
//
// Requests that the beacon node identify information about its implementation in a format similar to
// a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
//
// GET /eth/v1/node/version
func (c *Client) GetNodeVersion(ctx context.Context) (GetNodeVersionRes, error) {
	res, err := c.sendGetNodeVersion(ctx)
	return res, err
}

func (c *Client) sendGetNodeVersion(ctx context.Context) (res GetNodeVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeVersion"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/version"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetNodeVersion",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/version"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetNodeVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPeer invokes getPeer operation.
//
// Retrieves data about the given peer.
//
// GET /eth/v1/node/peers/{peer_id}
func (c *Client) GetPeer(ctx context.Context, params GetPeerParams) (GetPeerRes, error) {
	res, err := c.sendGetPeer(ctx, params)
	return res, err
}

func (c *Client) sendGetPeer(ctx context.Context, params GetPeerParams) (res GetPeerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeer"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peers/{peer_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPeer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/node/peers/"
	{
		// Encode "peer_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "peer_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PeerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPeerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPeerCount invokes getPeerCount operation.
//
// Retrieves number of known peers.
//
// GET /eth/v1/node/peer_count
func (c *Client) GetPeerCount(ctx context.Context) (GetPeerCountRes, error) {
	res, err := c.sendGetPeerCount(ctx)
	return res, err
}

func (c *Client) sendGetPeerCount(ctx context.Context) (res GetPeerCountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeerCount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peer_count"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPeerCount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/peer_count"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPeerCountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPeers invokes getPeers operation.
//
// Retrieves data about the node's network peers. By default this returns all peers. Multiple query
// params are combined using AND conditions.
//
// GET /eth/v1/node/peers
func (c *Client) GetPeers(ctx context.Context, params GetPeersParams) (GetPeersRes, error) {
	res, err := c.sendGetPeers(ctx, params)
	return res, err
}

func (c *Client) sendGetPeers(ctx context.Context, params GetPeersParams) (res GetPeersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPeers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/peers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.State {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Direction {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPeersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolAttestations invokes getPoolAttestations operation.
//
// Retrieves attestations known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attestations
func (c *Client) GetPoolAttestations(ctx context.Context, params GetPoolAttestationsParams) (GetPoolAttestationsRes, error) {
	res, err := c.sendGetPoolAttestations(ctx, params)
	return res, err
}

func (c *Client) sendGetPoolAttestations(ctx context.Context, params GetPoolAttestationsParams) (res GetPoolAttestationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolAttestations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attestations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPoolAttestations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/attestations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Slot.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "committee_index" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "committee_index",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CommitteeIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPoolAttestationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolAttesterSlashings invokes getPoolAttesterSlashings operation.
//
// Retrieves attester slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attester_slashings
func (c *Client) GetPoolAttesterSlashings(ctx context.Context) (GetPoolAttesterSlashingsRes, error) {
	res, err := c.sendGetPoolAttesterSlashings(ctx)
	return res, err
}

func (c *Client) sendGetPoolAttesterSlashings(ctx context.Context) (res GetPoolAttesterSlashingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolAttesterSlashings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attester_slashings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPoolAttesterSlashings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/attester_slashings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPoolAttesterSlashingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolBLSToExecutionChanges invokes getPoolBLSToExecutionChanges operation.
//
// Retrieves BLS to execution changes known by the node but not necessarily incorporated into any
// block.
//
// GET /eth/v1/beacon/pool/bls_to_execution_changes
func (c *Client) GetPoolBLSToExecutionChanges(ctx context.Context) (GetPoolBLSToExecutionChangesRes, error) {
	res, err := c.sendGetPoolBLSToExecutionChanges(ctx)
	return res, err
}

func (c *Client) sendGetPoolBLSToExecutionChanges(ctx context.Context) (res GetPoolBLSToExecutionChangesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolBLSToExecutionChanges"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/bls_to_execution_changes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPoolBLSToExecutionChanges",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/bls_to_execution_changes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPoolBLSToExecutionChangesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolProposerSlashings invokes getPoolProposerSlashings operation.
//
// Retrieves proposer slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/proposer_slashings
func (c *Client) GetPoolProposerSlashings(ctx context.Context) (GetPoolProposerSlashingsRes, error) {
	res, err := c.sendGetPoolProposerSlashings(ctx)
	return res, err
}

func (c *Client) sendGetPoolProposerSlashings(ctx context.Context) (res GetPoolProposerSlashingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolProposerSlashings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/proposer_slashings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPoolProposerSlashings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/proposer_slashings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPoolProposerSlashingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolVoluntaryExits invokes getPoolVoluntaryExits operation.
//
// Retrieves voluntary exits known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/voluntary_exits
func (c *Client) GetPoolVoluntaryExits(ctx context.Context) (GetPoolVoluntaryExitsRes, error) {
	res, err := c.sendGetPoolVoluntaryExits(ctx)
	return res, err
}

func (c *Client) sendGetPoolVoluntaryExits(ctx context.Context) (res GetPoolVoluntaryExitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolVoluntaryExits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/voluntary_exits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetPoolVoluntaryExits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/voluntary_exits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPoolVoluntaryExitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProposerDuties invokes getProposerDuties operation.
//
// Request beacon node to provide all validators that are scheduled to propose a block in the given
// epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization could occur
// that results in a change of duties. For full safety, you should monitor head events and confirm
// the dependent root in this response matches:
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) -
// 1)` or the genesis block root in the case of underflow.
//
// GET /eth/v1/validator/duties/proposer/{epoch}
func (c *Client) GetProposerDuties(ctx context.Context, params GetProposerDutiesParams) (GetProposerDutiesRes, error) {
	res, err := c.sendGetProposerDuties(ctx, params)
	return res, err
}

func (c *Client) sendGetProposerDuties(ctx context.Context, params GetProposerDutiesParams) (res GetProposerDutiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProposerDuties"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/proposer/{epoch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetProposerDuties",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/validator/duties/proposer/"
	{
		// Encode "epoch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "epoch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Epoch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProposerDutiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpec invokes getSpec operation.
//
// Retrieve specification configuration used on this node.  The configuration should include:
// - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and
// [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.
// md#constants) values
// - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values
// - Configuration for the beacon node, for example the [mainnet](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values
// Values are returned with following format:
// - any value starting with 0x in the spec is returned as a hex string
// - numeric values are returned as a quoted integer.
//
// GET /eth/v1/config/spec
func (c *Client) GetSpec(ctx context.Context) (GetSpecRes, error) {
	res, err := c.sendGetSpec(ctx)
	return res, err
}

func (c *Client) sendGetSpec(ctx context.Context) (res GetSpecRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpec"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/spec"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSpec",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/config/spec"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpecResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateFinalityCheckpoints invokes getStateFinalityCheckpoints operation.
//
// Returns finality checkpoints for state with given 'stateId'.
// In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
//
// GET /eth/v1/beacon/states/{state_id}/finality_checkpoints
func (c *Client) GetStateFinalityCheckpoints(ctx context.Context, params GetStateFinalityCheckpointsParams) (GetStateFinalityCheckpointsRes, error) {
	res, err := c.sendGetStateFinalityCheckpoints(ctx, params)
	return res, err
}

func (c *Client) sendGetStateFinalityCheckpoints(ctx context.Context, params GetStateFinalityCheckpointsParams) (res GetStateFinalityCheckpointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateFinalityCheckpoints"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/finality_checkpoints"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateFinalityCheckpoints",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/finality_checkpoints"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateFinalityCheckpointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateFork invokes getStateFork operation.
//
// Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.
// md#fork) object for state with given 'stateId'.
//
// GET /eth/v1/beacon/states/{state_id}/fork
func (c *Client) GetStateFork(ctx context.Context, params GetStateForkParams) (GetStateForkRes, error) {
	res, err := c.sendGetStateFork(ctx, params)
	return res, err
}

func (c *Client) sendGetStateFork(ctx context.Context, params GetStateForkParams) (res GetStateForkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateFork"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/fork"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateFork",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/fork"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateForkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateRandao invokes getStateRandao operation.
//
// Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.
// If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.
// By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix.
// Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are
// applied.
//
// GET /eth/v1/beacon/states/{state_id}/randao
func (c *Client) GetStateRandao(ctx context.Context, params GetStateRandaoParams) (GetStateRandaoRes, error) {
	res, err := c.sendGetStateRandao(ctx, params)
	return res, err
}

func (c *Client) sendGetStateRandao(ctx context.Context, params GetStateRandaoParams) (res GetStateRandaoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateRandao"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/randao"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateRandao",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/randao"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "epoch" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "epoch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Epoch.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateRandaoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateRoot invokes getStateRoot operation.
//
// Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be
// returned.
//
// GET /eth/v1/beacon/states/{state_id}/root
func (c *Client) GetStateRoot(ctx context.Context, params GetStateRootParams) (GetStateRootRes, error) {
	res, err := c.sendGetStateRoot(ctx, params)
	return res, err
}

func (c *Client) sendGetStateRoot(ctx context.Context, params GetStateRootParams) (res GetStateRootRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateRoot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/root"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateRoot",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/root"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateRootResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateV2 invokes getStateV2 operation.
//
// Returns full BeaconState object for given stateId.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/debug/beacon/states/{state_id}
func (c *Client) GetStateV2(ctx context.Context, params GetStateV2Params) (GetStateV2Res, error) {
	res, err := c.sendGetStateV2(ctx, params)
	return res, err
}

func (c *Client) sendGetStateV2(ctx context.Context, params GetStateV2Params) (res GetStateV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/debug/beacon/states/{state_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v2/debug/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateValidator invokes getStateValidator operation.
//
// Returns validator specified by state and id or public key along with status and balance.
//
// GET /eth/v1/beacon/states/{state_id}/validators/{validator_id}
func (c *Client) GetStateValidator(ctx context.Context, params GetStateValidatorParams) (GetStateValidatorRes, error) {
	res, err := c.sendGetStateValidator(ctx, params)
	return res, err
}

func (c *Client) sendGetStateValidator(ctx context.Context, params GetStateValidatorParams) (res GetStateValidatorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidator"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validators/{validator_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateValidator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validators/"
	{
		// Encode "validator_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "validator_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ValidatorID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateValidatorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateValidatorBalances invokes getStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validator_balances
func (c *Client) GetStateValidatorBalances(ctx context.Context, params GetStateValidatorBalancesParams) (GetStateValidatorBalancesRes, error) {
	res, err := c.sendGetStateValidatorBalances(ctx, params)
	return res, err
}

func (c *Client) sendGetStateValidatorBalances(ctx context.Context, params GetStateValidatorBalancesParams) (res GetStateValidatorBalancesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidatorBalances"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validator_balances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateValidatorBalances",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validator_balances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateValidatorBalancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStateValidators invokes getStateValidators operation.
//
// Returns filterable list of validators with their balance, status and index.
// Information will be returned for all indices or public key that match known validators.  If an
// index or public key does not
// match any known validator, no information will be returned but this will not cause an error.
// There are no guarantees for the
// returned data in terms of ordering; both the index and public key are returned for each validator,
// and can be used to confirm
// for which inputs a response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validators
func (c *Client) GetStateValidators(ctx context.Context, params GetStateValidatorsParams) (GetStateValidatorsRes, error) {
	res, err := c.sendGetStateValidators(ctx, params)
	return res, err
}

func (c *Client) sendGetStateValidators(ctx context.Context, params GetStateValidatorsParams) (res GetStateValidatorsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validators"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStateValidators",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStateValidatorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSyncCommitteeDuties invokes getSyncCommitteeDuties operation.
//
// Requests the beacon node to provide a set of sync committee duties for a particular epoch.
//
// POST /eth/v1/validator/duties/sync/{epoch}
func (c *Client) GetSyncCommitteeDuties(ctx context.Context, request []string, params GetSyncCommitteeDutiesParams) (GetSyncCommitteeDutiesRes, error) {
	res, err := c.sendGetSyncCommitteeDuties(ctx, request, params)
	return res, err
}

func (c *Client) sendGetSyncCommitteeDuties(ctx context.Context, request []string, params GetSyncCommitteeDutiesParams) (res GetSyncCommitteeDutiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncCommitteeDuties"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/sync/{epoch}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSyncCommitteeDuties",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/validator/duties/sync/"
	{
		// Encode "epoch" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "epoch",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Epoch))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetSyncCommitteeDutiesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSyncCommitteeDutiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSyncCommitteeRewards invokes getSyncCommitteeRewards operation.
//
// Retrieves rewards info for sync committee members specified by array of public keys or validator
// index. If no array is provided, return reward info for every committee member.
//
// POST /eth/v1/beacon/rewards/sync_committee/{block_id}
func (c *Client) GetSyncCommitteeRewards(ctx context.Context, request []string, params GetSyncCommitteeRewardsParams) (GetSyncCommitteeRewardsRes, error) {
	res, err := c.sendGetSyncCommitteeRewards(ctx, request, params)
	return res, err
}

func (c *Client) sendGetSyncCommitteeRewards(ctx context.Context, request []string, params GetSyncCommitteeRewardsParams) (res GetSyncCommitteeRewardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncCommitteeRewards"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/sync_committee/{block_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSyncCommitteeRewards",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/beacon/rewards/sync_committee/"
	{
		// Encode "block_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "block_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BlockID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetSyncCommitteeRewardsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSyncCommitteeRewardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSyncingStatus invokes getSyncingStatus operation.
//
// Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it
// is up to.
//
// GET /eth/v1/node/syncing
func (c *Client) GetSyncingStatus(ctx context.Context) (GetSyncingStatusRes, error) {
	res, err := c.sendGetSyncingStatus(ctx)
	return res, err
}

func (c *Client) sendGetSyncingStatus(ctx context.Context) (res GetSyncingStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncingStatus"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/syncing"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSyncingStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/node/syncing"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSyncingStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostStateValidatorBalances invokes postStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// POST /eth/v1/beacon/states/{state_id}/validator_balances
func (c *Client) PostStateValidatorBalances(ctx context.Context, request []string, params PostStateValidatorBalancesParams) (PostStateValidatorBalancesRes, error) {
	res, err := c.sendPostStateValidatorBalances(ctx, request, params)
	return res, err
}

func (c *Client) sendPostStateValidatorBalances(ctx context.Context, request []string, params PostStateValidatorBalancesParams) (res PostStateValidatorBalancesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("postStateValidatorBalances"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validator_balances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PostStateValidatorBalances",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/eth/v1/beacon/states/"
	{
		// Encode "state_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "state_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StateID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validator_balances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostStateValidatorBalancesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostStateValidatorBalancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PrepareBeaconCommitteeSubnet invokes prepareBeaconCommitteeSubnet operation.
//
// After beacon node receives this request,
// search using discv5 for peers related to this subnet
// and replace current peers with those ones if necessary
// If validator `is_aggregator`, beacon node must:
// - announce subnet topic subscription on gossipsub
// - aggregate attestations received on that subnet.
//
// POST /eth/v1/validator/beacon_committee_subscriptions
func (c *Client) PrepareBeaconCommitteeSubnet(ctx context.Context, request []PrepareBeaconCommitteeSubnetReqItem) (PrepareBeaconCommitteeSubnetRes, error) {
	res, err := c.sendPrepareBeaconCommitteeSubnet(ctx, request)
	return res, err
}

func (c *Client) sendPrepareBeaconCommitteeSubnet(ctx context.Context, request []PrepareBeaconCommitteeSubnetReqItem) (res PrepareBeaconCommitteeSubnetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareBeaconCommitteeSubnet"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/beacon_committee_subscriptions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PrepareBeaconCommitteeSubnet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/beacon_committee_subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePrepareBeaconCommitteeSubnetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePrepareBeaconCommitteeSubnetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PrepareBeaconProposer invokes prepareBeaconProposer operation.
//
// Prepares the beacon node for potential proposers by supplying information
// required when proposing blocks for the given validators.  The information
// supplied for each validator index will persist through the epoch in which
// the call is submitted and for a further two epochs after that, or until the
// beacon node restarts.  It is expected that validator clients will send this
// information periodically, for example each epoch, to ensure beacon nodes have
// correct and timely fee recipient information.
// Note that there is no guarantee that the beacon node will use the supplied fee
// recipient when creating a block proposal, so on receipt of a proposed block the
// validator should confirm that it finds the fee recipient within the block
// acceptable before signing it.
// Also note that requests containing currently inactive or unknown validator
// indices will be accepted, as they may become active at a later epoch.
//
// POST /eth/v1/validator/prepare_beacon_proposer
func (c *Client) PrepareBeaconProposer(ctx context.Context, request []PrepareBeaconProposerReqItem) (PrepareBeaconProposerRes, error) {
	res, err := c.sendPrepareBeaconProposer(ctx, request)
	return res, err
}

func (c *Client) sendPrepareBeaconProposer(ctx context.Context, request []PrepareBeaconProposerReqItem) (res PrepareBeaconProposerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareBeaconProposer"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/prepare_beacon_proposer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PrepareBeaconProposer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/prepare_beacon_proposer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePrepareBeaconProposerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePrepareBeaconProposerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PrepareSyncCommitteeSubnets invokes prepareSyncCommitteeSubnets operation.
//
// Subscribe to a number of sync committee subnets
// Sync committees are not present in phase0, but are required for Altair networks.
// Subscribing to sync committee subnets is an action performed by VC to enable network participation
// in Altair networks, and only required if the VC has an active validator in an active sync
// committee.
//
// POST /eth/v1/validator/sync_committee_subscriptions
func (c *Client) PrepareSyncCommitteeSubnets(ctx context.Context, request []PrepareSyncCommitteeSubnetsReqItem) (PrepareSyncCommitteeSubnetsRes, error) {
	res, err := c.sendPrepareSyncCommitteeSubnets(ctx, request)
	return res, err
}

func (c *Client) sendPrepareSyncCommitteeSubnets(ctx context.Context, request []PrepareSyncCommitteeSubnetsReqItem) (res PrepareSyncCommitteeSubnetsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareSyncCommitteeSubnets"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_subscriptions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PrepareSyncCommitteeSubnets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/sync_committee_subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePrepareSyncCommitteeSubnetsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePrepareSyncCommitteeSubnetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProduceAttestationData invokes produceAttestationData operation.
//
// Requests that the beacon node produce an AttestationData.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the attestation attests to a block
// that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/attestation_data
func (c *Client) ProduceAttestationData(ctx context.Context, params ProduceAttestationDataParams) (ProduceAttestationDataRes, error) {
	res, err := c.sendProduceAttestationData(ctx, params)
	return res, err
}

func (c *Client) sendProduceAttestationData(ctx context.Context, params ProduceAttestationDataParams) (res ProduceAttestationDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceAttestationData"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/attestation_data"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProduceAttestationData",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/attestation_data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "committee_index" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "committee_index",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CommitteeIndex))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProduceAttestationDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProduceBlindedBlock invokes produceBlindedBlock operation.
//
// Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.
// A blinded block is a block with only a transactions root, rather than a full transactions list.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
// Before Bellatrix, this endpoint will return a `BeaconBlock`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v1/validator/blinded_blocks/{slot}
func (c *Client) ProduceBlindedBlock(ctx context.Context, params ProduceBlindedBlockParams) (ProduceBlindedBlockRes, error) {
	res, err := c.sendProduceBlindedBlock(ctx, params)
	return res, err
}

func (c *Client) sendProduceBlindedBlock(ctx context.Context, params ProduceBlindedBlockParams) (res ProduceBlindedBlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlindedBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/blinded_blocks/{slot}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProduceBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v1/validator/blinded_blocks/"
	{
		// Encode "slot" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slot",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "randao_reveal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "randao_reveal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.RandaoReveal))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "graffiti" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "graffiti",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Graffiti.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProduceBlindedBlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProduceBlockV2 invokes produceBlockV2 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v2/validator/blocks/{slot}
func (c *Client) ProduceBlockV2(ctx context.Context, params ProduceBlockV2Params) (ProduceBlockV2Res, error) {
	res, err := c.sendProduceBlockV2(ctx, params)
	return res, err
}

func (c *Client) sendProduceBlockV2(ctx context.Context, params ProduceBlockV2Params) (res ProduceBlockV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlockV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/validator/blocks/{slot}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProduceBlockV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v2/validator/blocks/"
	{
		// Encode "slot" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slot",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "randao_reveal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "randao_reveal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.RandaoReveal))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "graffiti" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "graffiti",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Graffiti.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProduceBlockV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProduceBlockV3 invokes produceBlockV3 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator. The
// returned block may be blinded or unblinded, depending on the current state of the network as
// decided by the execution and beacon nodes.
// The beacon node must return an unblinded block if it obtains the execution payload from its
// paired execution node. It must only return a blinded block if it obtains the execution payload
// header from an MEV relay.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// GET /eth/v3/validator/blocks/{slot}
func (c *Client) ProduceBlockV3(ctx context.Context, params ProduceBlockV3Params) (ProduceBlockV3Res, error) {
	res, err := c.sendProduceBlockV3(ctx, params)
	return res, err
}

func (c *Client) sendProduceBlockV3(ctx context.Context, params ProduceBlockV3Params) (res ProduceBlockV3Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlockV3"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v3/validator/blocks/{slot}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProduceBlockV3",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/eth/v3/validator/blocks/"
	{
		// Encode "slot" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "slot",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "randao_reveal" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "randao_reveal",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.RandaoReveal))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "graffiti" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "graffiti",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Graffiti.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "builder_boost_factor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "builder_boost_factor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BuilderBoostFactor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProduceBlockV3Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProduceSyncCommitteeContribution invokes produceSyncCommitteeContribution operation.
//
// Requests that the beacon node produce a sync committee contribution.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the sync committee contribution
// refers to a block that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/sync_committee_contribution
func (c *Client) ProduceSyncCommitteeContribution(ctx context.Context, params ProduceSyncCommitteeContributionParams) (ProduceSyncCommitteeContributionRes, error) {
	res, err := c.sendProduceSyncCommitteeContribution(ctx, params)
	return res, err
}

func (c *Client) sendProduceSyncCommitteeContribution(ctx context.Context, params ProduceSyncCommitteeContributionParams) (res ProduceSyncCommitteeContributionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceSyncCommitteeContribution"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_contribution"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ProduceSyncCommitteeContribution",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/sync_committee_contribution"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "slot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "slot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Slot))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "subcommittee_index" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "subcommittee_index",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SubcommitteeIndex))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "beacon_block_root" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "beacon_block_root",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BeaconBlockRoot))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeProduceSyncCommitteeContributionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishAggregateAndProofs invokes publishAggregateAndProofs operation.
//
// Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
//
// POST /eth/v1/validator/aggregate_and_proofs
func (c *Client) PublishAggregateAndProofs(ctx context.Context, request []PublishAggregateAndProofsReqItem) (PublishAggregateAndProofsRes, error) {
	res, err := c.sendPublishAggregateAndProofs(ctx, request)
	return res, err
}

func (c *Client) sendPublishAggregateAndProofs(ctx context.Context, request []PublishAggregateAndProofsReqItem) (res PublishAggregateAndProofsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishAggregateAndProofs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/aggregate_and_proofs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishAggregateAndProofs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/aggregate_and_proofs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishAggregateAndProofsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishAggregateAndProofsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishBlindedBlock invokes publishBlindedBlock operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`.
//
// POST /eth/v1/beacon/blinded_blocks
func (c *Client) PublishBlindedBlock(ctx context.Context, request PublishBlindedBlockReqApplicationOctetStream, params PublishBlindedBlockParams) (PublishBlindedBlockRes, error) {
	res, err := c.sendPublishBlindedBlock(ctx, request, params)
	return res, err
}

func (c *Client) sendPublishBlindedBlock(ctx context.Context, request PublishBlindedBlockReqApplicationOctetStream, params PublishBlindedBlockParams) (res PublishBlindedBlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlindedBlock"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blinded_blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/blinded_blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishBlindedBlockRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Eth-Consensus-Version",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EthConsensusVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishBlindedBlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishBlindedBlockV2 invokes publishBlindedBlockV2 operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation`
// query parameter.
//
// POST /eth/v2/beacon/blinded_blocks
func (c *Client) PublishBlindedBlockV2(ctx context.Context, request PublishBlindedBlockV2ReqApplicationOctetStream, params PublishBlindedBlockV2Params) (PublishBlindedBlockV2Res, error) {
	res, err := c.sendPublishBlindedBlockV2(ctx, request, params)
	return res, err
}

func (c *Client) sendPublishBlindedBlockV2(ctx context.Context, request PublishBlindedBlockV2ReqApplicationOctetStream, params PublishBlindedBlockV2Params) (res PublishBlindedBlockV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlindedBlockV2"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blinded_blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishBlindedBlockV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v2/beacon/blinded_blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "broadcast_validation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "broadcast_validation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BroadcastValidation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishBlindedBlockV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Eth-Consensus-Version",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.EthConsensusVersion)))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishBlindedBlockV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishBlock invokes publishBlock operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs.
//
// POST /eth/v1/beacon/blocks
func (c *Client) PublishBlock(ctx context.Context, request PublishBlockReqApplicationOctetStream, params PublishBlockParams) (PublishBlockRes, error) {
	res, err := c.sendPublishBlock(ctx, request, params)
	return res, err
}

func (c *Client) sendPublishBlock(ctx context.Context, request PublishBlockReqApplicationOctetStream, params PublishBlockParams) (res PublishBlockRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlock"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishBlock",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishBlockRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Eth-Consensus-Version",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EthConsensusVersion.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishBlockResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishBlockV2 invokes publishBlockV2 operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into the state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the
// `broadcast_validation` query parameter.
//
// POST /eth/v2/beacon/blocks
func (c *Client) PublishBlockV2(ctx context.Context, request PublishBlockV2ReqApplicationOctetStream, params PublishBlockV2Params) (PublishBlockV2Res, error) {
	res, err := c.sendPublishBlockV2(ctx, request, params)
	return res, err
}

func (c *Client) sendPublishBlockV2(ctx context.Context, request PublishBlockV2ReqApplicationOctetStream, params PublishBlockV2Params) (res PublishBlockV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlockV2"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blocks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishBlockV2",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v2/beacon/blocks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "broadcast_validation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "broadcast_validation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BroadcastValidation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishBlockV2Request(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Eth-Consensus-Version",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.EthConsensusVersion)))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishBlockV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PublishContributionAndProofs invokes publishContributionAndProofs operation.
//
// Publish multiple signed sync committee contribution and proofs.
//
// POST /eth/v1/validator/contribution_and_proofs
func (c *Client) PublishContributionAndProofs(ctx context.Context, request []PublishContributionAndProofsReqItem) (PublishContributionAndProofsRes, error) {
	res, err := c.sendPublishContributionAndProofs(ctx, request)
	return res, err
}

func (c *Client) sendPublishContributionAndProofs(ctx context.Context, request []PublishContributionAndProofsReqItem) (res PublishContributionAndProofsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishContributionAndProofs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/contribution_and_proofs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PublishContributionAndProofs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/contribution_and_proofs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePublishContributionAndProofsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePublishContributionAndProofsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterValidator invokes registerValidator operation.
//
// Prepares the beacon node for engaging with external builders. The
// information must be sent by the beacon node to the builder network. It is
// expected that the validator client will send this information periodically
// to ensure the beacon node has correct and timely registration information
// to provide to builders. The validator client should not sign blinded beacon
// blocks that do not adhere to their latest fee recipient and gas limit
// preferences.
// Note that only registrations for active or pending validators must be sent to the builder network.
// Registrations for unknown or exited validators must be filtered out and not sent to the builder
// network.
//
// POST /eth/v1/validator/register_validator
func (c *Client) RegisterValidator(ctx context.Context, request []RegisterValidatorReqItem) (RegisterValidatorRes, error) {
	res, err := c.sendRegisterValidator(ctx, request)
	return res, err
}

func (c *Client) sendRegisterValidator(ctx context.Context, request []RegisterValidatorReqItem) (res RegisterValidatorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("registerValidator"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/register_validator"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RegisterValidator",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/register_validator"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterValidatorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRegisterValidatorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitBeaconCommitteeSelections invokes submitBeaconCommitteeSelections operation.
//
// This endpoint should be used by a validator client running as part of a distributed validator
// cluster, and is
// implemented by a distributed validator middleware client. This endpoint is used to exchange partial
// selection proofs for combined/aggregated selection proofs to allow a validator client
// to correctly determine if any of its validators has been selected to perform an attestation
// aggregation duty in a slot.
// Validator clients running in a distributed validator cluster must query this endpoint at the start
// of an epoch for the current and lookahead (next) epochs for
// all validators that have attester duties in the current and lookahead epochs. Consensus clients
// need not support this
// endpoint and may return a 501.
//
// POST /eth/v1/validator/beacon_committee_selections
func (c *Client) SubmitBeaconCommitteeSelections(ctx context.Context, request []SubmitBeaconCommitteeSelectionsReqItem) (SubmitBeaconCommitteeSelectionsRes, error) {
	res, err := c.sendSubmitBeaconCommitteeSelections(ctx, request)
	return res, err
}

func (c *Client) sendSubmitBeaconCommitteeSelections(ctx context.Context, request []SubmitBeaconCommitteeSelectionsReqItem) (res SubmitBeaconCommitteeSelectionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitBeaconCommitteeSelections"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/beacon_committee_selections"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitBeaconCommitteeSelections",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/beacon_committee_selections"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitBeaconCommitteeSelectionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitBeaconCommitteeSelectionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolAttestations invokes submitPoolAttestations operation.
//
// Submits Attestation objects to the node.  Each attestation in the request body is processed
// individually.
// If an attestation is validated successfully the node MUST publish that attestation on the
// appropriate subnet.
// If one or more attestations fail validation the node MUST return a 400 error with details of which
// attestations have failed, and why.
//
// POST /eth/v1/beacon/pool/attestations
func (c *Client) SubmitPoolAttestations(ctx context.Context, request []SubmitPoolAttestationsReqItem) (SubmitPoolAttestationsRes, error) {
	res, err := c.sendSubmitPoolAttestations(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolAttestations(ctx context.Context, request []SubmitPoolAttestationsReqItem) (res SubmitPoolAttestationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolAttestations"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attestations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolAttestations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/attestations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolAttestationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolAttestationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolAttesterSlashings invokes submitPoolAttesterSlashings operation.
//
// Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/attester_slashings
func (c *Client) SubmitPoolAttesterSlashings(ctx context.Context, request *SubmitPoolAttesterSlashingsReq) (SubmitPoolAttesterSlashingsRes, error) {
	res, err := c.sendSubmitPoolAttesterSlashings(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolAttesterSlashings(ctx context.Context, request *SubmitPoolAttesterSlashingsReq) (res SubmitPoolAttesterSlashingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolAttesterSlashings"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attester_slashings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolAttesterSlashings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/attester_slashings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolAttesterSlashingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolAttesterSlashingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolBLSToExecutionChange invokes submitPoolBLSToExecutionChange operation.
//
// Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST
// be broadcast to the network.
//
// POST /eth/v1/beacon/pool/bls_to_execution_changes
func (c *Client) SubmitPoolBLSToExecutionChange(ctx context.Context, request []SubmitPoolBLSToExecutionChangeReqItem) (SubmitPoolBLSToExecutionChangeRes, error) {
	res, err := c.sendSubmitPoolBLSToExecutionChange(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolBLSToExecutionChange(ctx context.Context, request []SubmitPoolBLSToExecutionChangeReqItem) (res SubmitPoolBLSToExecutionChangeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolBLSToExecutionChange"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/bls_to_execution_changes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolBLSToExecutionChange",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/bls_to_execution_changes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolBLSToExecutionChangeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolBLSToExecutionChangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolProposerSlashings invokes submitPoolProposerSlashings operation.
//
// Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/proposer_slashings
func (c *Client) SubmitPoolProposerSlashings(ctx context.Context, request *SubmitPoolProposerSlashingsReq) (SubmitPoolProposerSlashingsRes, error) {
	res, err := c.sendSubmitPoolProposerSlashings(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolProposerSlashings(ctx context.Context, request *SubmitPoolProposerSlashingsReq) (res SubmitPoolProposerSlashingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolProposerSlashings"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/proposer_slashings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolProposerSlashings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/proposer_slashings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolProposerSlashingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolProposerSlashingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolSyncCommitteeSignatures invokes submitPoolSyncCommitteeSignatures operation.
//
// Submits sync committee signature objects to the node.
// Sync committee signatures are not present in phase0, but are required for Altair networks.
// If a sync committee signature is validated successfully the node MUST publish that sync committee
// signature on all applicable subnets.
// If one or more sync committee signatures fail validation the node MUST return a 400 error with
// details of which sync committee signatures have failed, and why.
//
// POST /eth/v1/beacon/pool/sync_committees
func (c *Client) SubmitPoolSyncCommitteeSignatures(ctx context.Context, request []SubmitPoolSyncCommitteeSignaturesReqItem) (SubmitPoolSyncCommitteeSignaturesRes, error) {
	res, err := c.sendSubmitPoolSyncCommitteeSignatures(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolSyncCommitteeSignatures(ctx context.Context, request []SubmitPoolSyncCommitteeSignaturesReqItem) (res SubmitPoolSyncCommitteeSignaturesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolSyncCommitteeSignatures"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/sync_committees"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolSyncCommitteeSignatures",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/sync_committees"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolSyncCommitteeSignaturesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolSyncCommitteeSignaturesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitPoolVoluntaryExit invokes submitPoolVoluntaryExit operation.
//
// Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it
// to network.
//
// POST /eth/v1/beacon/pool/voluntary_exits
func (c *Client) SubmitPoolVoluntaryExit(ctx context.Context, request *SubmitPoolVoluntaryExitReq) (SubmitPoolVoluntaryExitRes, error) {
	res, err := c.sendSubmitPoolVoluntaryExit(ctx, request)
	return res, err
}

func (c *Client) sendSubmitPoolVoluntaryExit(ctx context.Context, request *SubmitPoolVoluntaryExitReq) (res SubmitPoolVoluntaryExitRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolVoluntaryExit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/voluntary_exits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitPoolVoluntaryExit",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/beacon/pool/voluntary_exits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitPoolVoluntaryExitRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitPoolVoluntaryExitResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitSyncCommitteeSelections invokes submitSyncCommitteeSelections operation.
//
// Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated
// sync
// committee selection. This endpoint should be used by a validator client running as part of a
// distributed
// validator cluster, and is implemented by a distributed validator middleware client. This endpoint
// is
// used to exchange partial selection proofs (slot signatures) for combined/aggregated selection
// proofs to
// allow a validator client to correctly determine if any of its validators has been selected to
// perform a
// sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a
// distributed validator cluster must query this endpoint
// at the start of each slot for all validators that are included in the current sync committee.
// Consensus
// clients need not support this endpoint and may return a 501.
//
// POST /eth/v1/validator/sync_committee_selections
func (c *Client) SubmitSyncCommitteeSelections(ctx context.Context, request []SubmitSyncCommitteeSelectionsReqItem) (SubmitSyncCommitteeSelectionsRes, error) {
	res, err := c.sendSubmitSyncCommitteeSelections(ctx, request)
	return res, err
}

func (c *Client) sendSubmitSyncCommitteeSelections(ctx context.Context, request []SubmitSyncCommitteeSelectionsReqItem) (res SubmitSyncCommitteeSelectionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitSyncCommitteeSelections"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_selections"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SubmitSyncCommitteeSelections",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/eth/v1/validator/sync_committee_selections"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitSyncCommitteeSelectionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitSyncCommitteeSelectionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
