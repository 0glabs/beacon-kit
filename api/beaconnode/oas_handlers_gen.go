// Code generated by ogen, DO NOT EDIT.

package beaconnode

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
)

// handleEventstreamRequest handles eventstream operation.
//
// Provides endpoint to subscribe to beacon node Server-Sent-Events stream.
// Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.
// html#the-eventsource-interface)
// implementation to listen on those events.
// Servers _may_ send SSE comments beginning with `:` for any purpose, including to keep the
// event stream connection alive in the presence of proxy servers.
//
// GET /eth/v1/events
func (s *Server) handleEventstreamRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("eventstream"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "Eventstream",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "Eventstream",
			ID:   "eventstream",
		}
	)
	params, err := decodeEventstreamParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response EventstreamRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "Eventstream",
			OperationSummary: "Subscribe to beacon node events",
			OperationID:      "eventstream",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "topics",
					In:   "query",
				}: params.Topics,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EventstreamParams
			Response = EventstreamRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEventstreamParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.Eventstream(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.Eventstream(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEventstreamResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAggregatedAttestationRequest handles getAggregatedAttestation operation.
//
// Aggregates all attestations matching given attestation data root and slot.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the aggregated attestation attests
// to a block that has not been fully verified by an execution engine).
// A 404 error must be returned if no attestation is available for the requested
// `attestation_data_root`.
//
// GET /eth/v1/validator/aggregate_attestation
func (s *Server) handleGetAggregatedAttestationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAggregatedAttestation"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/aggregate_attestation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAggregatedAttestation",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAggregatedAttestation",
			ID:   "getAggregatedAttestation",
		}
	)
	params, err := decodeGetAggregatedAttestationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetAggregatedAttestationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAggregatedAttestation",
			OperationSummary: "Get aggregated attestation",
			OperationID:      "getAggregatedAttestation",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "attestation_data_root",
					In:   "query",
				}: params.AttestationDataRoot,
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAggregatedAttestationParams
			Response = GetAggregatedAttestationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAggregatedAttestationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAggregatedAttestation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAggregatedAttestation(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAggregatedAttestationResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAttestationsRewardsRequest handles getAttestationsRewards operation.
//
// Retrieve attestation reward info for validators specified by array of public keys or validator
// index. If no array is provided, return reward info for every validator.
//
// POST /eth/v1/beacon/rewards/attestations/{epoch}
func (s *Server) handleGetAttestationsRewardsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttestationsRewards"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/attestations/{epoch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAttestationsRewards",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAttestationsRewards",
			ID:   "getAttestationsRewards",
		}
	)
	params, err := decodeGetAttestationsRewardsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetAttestationsRewardsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetAttestationsRewardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAttestationsRewards",
			OperationSummary: "Get attestations rewards",
			OperationID:      "getAttestationsRewards",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "epoch",
					In:   "path",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GetAttestationsRewardsParams
			Response = GetAttestationsRewardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAttestationsRewardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAttestationsRewards(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAttestationsRewards(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAttestationsRewardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAttesterDutiesRequest handles getAttesterDuties operation.
//
// Requests the beacon node to provide a set of attestation duties, which should be performed by
// validators, for a particular epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization (of >
// MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties. For full safety, you
// should monitor head events and confirm the dependent root in this response matches:
// - event.previous_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) + 1 == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1)
// - 1)` or the genesis block root in the case of underflow.
//
// POST /eth/v1/validator/duties/attester/{epoch}
func (s *Server) handleGetAttesterDutiesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAttesterDuties"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/attester/{epoch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetAttesterDuties",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetAttesterDuties",
			ID:   "getAttesterDuties",
		}
	)
	params, err := decodeGetAttesterDutiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetAttesterDutiesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetAttesterDutiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetAttesterDuties",
			OperationSummary: "Get attester duties",
			OperationID:      "getAttesterDuties",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "epoch",
					In:   "path",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GetAttesterDutiesParams
			Response = GetAttesterDutiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAttesterDutiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAttesterDuties(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAttesterDuties(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAttesterDutiesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlindedBlockRequest handles getBlindedBlock operation.
//
// Retrieves blinded block for given block ID.
// Depending on `Accept` header it can be returned either as JSON or as bytes serialized by SSZ.
//
// GET /eth/v1/beacon/blinded_blocks/{block_id}
func (s *Server) handleGetBlindedBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlindedBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blinded_blocks/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlindedBlock",
			ID:   "getBlindedBlock",
		}
	)
	params, err := decodeGetBlindedBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlindedBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlindedBlock",
			OperationSummary: "Get blinded block",
			OperationID:      "getBlindedBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlindedBlockParams
			Response = GetBlindedBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlindedBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlindedBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlindedBlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlindedBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlobSidecarsRequest handles getBlobSidecars operation.
//
// Retrieves blob sidecars for a given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
// If the `indices` parameter is specified, only the blob sidecars with the specified indices will be
// returned. There are no guarantees
// for the returned blob sidecars in terms of ordering.
//
// GET /eth/v1/beacon/blob_sidecars/{block_id}
func (s *Server) handleGetBlobSidecarsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlobSidecars"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blob_sidecars/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlobSidecars",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlobSidecars",
			ID:   "getBlobSidecars",
		}
	)
	params, err := decodeGetBlobSidecarsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlobSidecarsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlobSidecars",
			OperationSummary: "Get blob sidecars",
			OperationID:      "getBlobSidecars",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
				{
					Name: "indices",
					In:   "query",
				}: params.Indices,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlobSidecarsParams
			Response = GetBlobSidecarsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlobSidecarsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlobSidecars(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlobSidecars(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlobSidecarsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockAttestationsRequest handles getBlockAttestations operation.
//
// Retrieves attestation included in requested block.
//
// GET /eth/v1/beacon/blocks/{block_id}/attestations
func (s *Server) handleGetBlockAttestationsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockAttestations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks/{block_id}/attestations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockAttestations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockAttestations",
			ID:   "getBlockAttestations",
		}
	)
	params, err := decodeGetBlockAttestationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockAttestationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockAttestations",
			OperationSummary: "Get block attestations",
			OperationID:      "getBlockAttestations",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockAttestationsParams
			Response = GetBlockAttestationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockAttestationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockAttestations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockAttestations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockAttestationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockHeaderRequest handles getBlockHeader operation.
//
// Retrieves block header for given block id.
//
// GET /eth/v1/beacon/headers/{block_id}
func (s *Server) handleGetBlockHeaderRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockHeader"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/headers/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockHeader",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockHeader",
			ID:   "getBlockHeader",
		}
	)
	params, err := decodeGetBlockHeaderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockHeaderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockHeader",
			OperationSummary: "Get block header",
			OperationID:      "getBlockHeader",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockHeaderParams
			Response = GetBlockHeaderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockHeaderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockHeader(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockHeader(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockHeaderResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockHeadersRequest handles getBlockHeaders operation.
//
// Retrieves block headers matching given query. By default it will fetch current head slot blocks.
//
// GET /eth/v1/beacon/headers
func (s *Server) handleGetBlockHeadersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockHeaders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/headers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockHeaders",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockHeaders",
			ID:   "getBlockHeaders",
		}
	)
	params, err := decodeGetBlockHeadersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockHeadersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockHeaders",
			OperationSummary: "Get block headers",
			OperationID:      "getBlockHeaders",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
				{
					Name: "parent_root",
					In:   "query",
				}: params.ParentRoot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockHeadersParams
			Response = GetBlockHeadersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockHeadersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockHeaders(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockHeaders(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockHeadersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockRewardsRequest handles getBlockRewards operation.
//
// Retrieve block reward info for a single block.
//
// GET /eth/v1/beacon/rewards/blocks/{block_id}
func (s *Server) handleGetBlockRewardsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockRewards"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/blocks/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockRewards",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockRewards",
			ID:   "getBlockRewards",
		}
	)
	params, err := decodeGetBlockRewardsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockRewardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockRewards",
			OperationSummary: "Get block rewards",
			OperationID:      "getBlockRewards",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockRewardsParams
			Response = GetBlockRewardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockRewardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockRewards(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockRewards(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockRewardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockRootRequest handles getBlockRoot operation.
//
// Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
//
// GET /eth/v1/beacon/blocks/{block_id}/root
func (s *Server) handleGetBlockRootRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockRoot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks/{block_id}/root"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockRoot",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockRoot",
			ID:   "getBlockRoot",
		}
	)
	params, err := decodeGetBlockRootParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockRootRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockRoot",
			OperationSummary: "Get block root",
			OperationID:      "getBlockRoot",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockRootParams
			Response = GetBlockRootRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockRootParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockRoot(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockRoot(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockRootResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetBlockV2Request handles getBlockV2 operation.
//
// Retrieves block details for given block id.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/beacon/blocks/{block_id}
func (s *Server) handleGetBlockV2Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getBlockV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blocks/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetBlockV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetBlockV2",
			ID:   "getBlockV2",
		}
	)
	params, err := decodeGetBlockV2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetBlockV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetBlockV2",
			OperationSummary: "Get block",
			OperationID:      "getBlockV2",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetBlockV2Params
			Response = GetBlockV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetBlockV2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetBlockV2(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetBlockV2(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetBlockV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDebugChainHeadsV2Request handles getDebugChainHeadsV2 operation.
//
// Retrieves all possible chain heads (leaves of fork choice tree).
//
// GET /eth/v2/debug/beacon/heads
func (s *Server) handleGetDebugChainHeadsV2Request(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDebugChainHeadsV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/debug/beacon/heads"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDebugChainHeadsV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetDebugChainHeadsV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDebugChainHeadsV2",
			OperationSummary: "Get fork choice leaves",
			OperationID:      "getDebugChainHeadsV2",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDebugChainHeadsV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDebugChainHeadsV2(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDebugChainHeadsV2(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDebugChainHeadsV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDebugForkChoiceRequest handles getDebugForkChoice operation.
//
// Retrieves all current fork choice context.
//
// GET /eth/v1/debug/fork_choice
func (s *Server) handleGetDebugForkChoiceRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDebugForkChoice"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/debug/fork_choice"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDebugForkChoice",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetDebugForkChoiceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDebugForkChoice",
			OperationSummary: "Get fork choice array",
			OperationID:      "getDebugForkChoice",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDebugForkChoiceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDebugForkChoice(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDebugForkChoice(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDebugForkChoiceResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDepositContractRequest handles getDepositContract operation.
//
// Retrieve Eth1 deposit contract address and chain ID.
//
// GET /eth/v1/config/deposit_contract
func (s *Server) handleGetDepositContractRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDepositContract"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/deposit_contract"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDepositContract",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetDepositContractRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDepositContract",
			OperationSummary: "Get deposit contract address.",
			OperationID:      "getDepositContract",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDepositContractRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDepositContract(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDepositContract(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDepositContractResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDepositSnapshotRequest handles getDepositSnapshot operation.
//
// Retrieve [EIP-4881](https://eips.ethereum.org/EIPS/eip-4881) Deposit Tree Snapshot.
// Depending on `Accept` header it can be returned either as json or as bytes serialzed by SSZ.
//
// GET /eth/v1/beacon/deposit_snapshot
func (s *Server) handleGetDepositSnapshotRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDepositSnapshot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/deposit_snapshot"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetDepositSnapshot",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetDepositSnapshotRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetDepositSnapshot",
			OperationSummary: "Get Deposit Tree Snapshot",
			OperationID:      "getDepositSnapshot",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetDepositSnapshotRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDepositSnapshot(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDepositSnapshot(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDepositSnapshotResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEpochCommitteesRequest handles getEpochCommittees operation.
//
// Retrieves the committees for the given state.
//
// GET /eth/v1/beacon/states/{state_id}/committees
func (s *Server) handleGetEpochCommitteesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEpochCommittees"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/committees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEpochCommittees",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEpochCommittees",
			ID:   "getEpochCommittees",
		}
	)
	params, err := decodeGetEpochCommitteesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEpochCommitteesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEpochCommittees",
			OperationSummary: "Get all committees for a state.",
			OperationID:      "getEpochCommittees",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "epoch",
					In:   "query",
				}: params.Epoch,
				{
					Name: "index",
					In:   "query",
				}: params.Index,
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEpochCommitteesParams
			Response = GetEpochCommitteesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEpochCommitteesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEpochCommittees(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEpochCommittees(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEpochCommitteesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEpochSyncCommitteesRequest handles getEpochSyncCommittees operation.
//
// Retrieves the current sync committee for the given state. Also returns the subcommittee
// assignments.
//
// GET /eth/v1/beacon/states/{state_id}/sync_committees
func (s *Server) handleGetEpochSyncCommitteesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEpochSyncCommittees"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/sync_committees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetEpochSyncCommittees",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEpochSyncCommittees",
			ID:   "getEpochSyncCommittees",
		}
	)
	params, err := decodeGetEpochSyncCommitteesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEpochSyncCommitteesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEpochSyncCommittees",
			OperationSummary: "Get sync committees for a state.",
			OperationID:      "getEpochSyncCommittees",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "epoch",
					In:   "query",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEpochSyncCommitteesParams
			Response = GetEpochSyncCommitteesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEpochSyncCommitteesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEpochSyncCommittees(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEpochSyncCommittees(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEpochSyncCommitteesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetForkScheduleRequest handles getForkSchedule operation.
//
// Retrieve all forks, past present and future, of which this node is aware.
//
// GET /eth/v1/config/fork_schedule
func (s *Server) handleGetForkScheduleRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getForkSchedule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/fork_schedule"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetForkSchedule",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetForkScheduleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetForkSchedule",
			OperationSummary: "Get scheduled upcoming forks.",
			OperationID:      "getForkSchedule",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetForkScheduleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetForkSchedule(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetForkSchedule(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetForkScheduleResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetGenesisRequest handles getGenesis operation.
//
// Retrieve details of the chain's genesis which can be used to identify chain.
//
// GET /eth/v1/beacon/genesis
func (s *Server) handleGetGenesisRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getGenesis"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/genesis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetGenesis",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetGenesisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetGenesis",
			OperationSummary: "Retrieve details of the chain's genesis.",
			OperationID:      "getGenesis",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetGenesisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetGenesis(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetGenesis(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetGenesisResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetHealthRequest handles getHealth operation.
//
// Returns node health status in http status codes. Useful for load balancers.
//
// GET /eth/v1/node/health
func (s *Server) handleGetHealthRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getHealth"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/health"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetHealth",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetHealth",
			ID:   "getHealth",
		}
	)
	params, err := decodeGetHealthParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetHealthRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetHealth",
			OperationSummary: "Get health check",
			OperationID:      "getHealth",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "syncing_status",
					In:   "query",
				}: params.SyncingStatus,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetHealthParams
			Response = GetHealthRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetHealthParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetHealth(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetHealth(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetHealthResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLightClientBootstrapRequest handles getLightClientBootstrap operation.
//
// Requests the [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientbootstrap) structure corresponding to a
// given post-Altair beacon block root.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_bootstrap`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_bootstrap). To fulfill a request, the requested block's post state needs to
// be known.
//
// GET /eth/v1/beacon/light_client/bootstrap/{block_root}
func (s *Server) handleGetLightClientBootstrapRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientBootstrap"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/bootstrap/{block_root}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetLightClientBootstrap",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLightClientBootstrap",
			ID:   "getLightClientBootstrap",
		}
	)
	params, err := decodeGetLightClientBootstrapParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLightClientBootstrapRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLightClientBootstrap",
			OperationSummary: "Get `LightClientBootstrap` structure for a requested block root",
			OperationID:      "getLightClientBootstrap",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "block_root",
					In:   "path",
				}: params.BlockRoot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLightClientBootstrapParams
			Response = GetLightClientBootstrapRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLightClientBootstrapParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLightClientBootstrap(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLightClientBootstrap(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLightClientBootstrapResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLightClientFinalityUpdateRequest handles getLightClientFinalityUpdate operation.
//
// Requests the latest [`LightClientFinalityUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientfinalityupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_finality_update).
//
// GET /eth/v1/beacon/light_client/finality_update
func (s *Server) handleGetLightClientFinalityUpdateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientFinalityUpdate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/finality_update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetLightClientFinalityUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetLightClientFinalityUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLightClientFinalityUpdate",
			OperationSummary: "Get the latest known `LightClientFinalityUpdate`",
			OperationID:      "getLightClientFinalityUpdate",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetLightClientFinalityUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLightClientFinalityUpdate(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLightClientFinalityUpdate(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLightClientFinalityUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLightClientOptimisticUpdateRequest handles getLightClientOptimisticUpdate operation.
//
// Requests the latest [`LightClientOptimisticUpdate`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/sync-protocol.
// md#lightclientoptimisticupdate) known by the server.
// Depending on the `Accept` header it can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in
// [`create_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/full-node.md#create_light_client_optimistic_update).
//
// GET /eth/v1/beacon/light_client/optimistic_update
func (s *Server) handleGetLightClientOptimisticUpdateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientOptimisticUpdate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/optimistic_update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetLightClientOptimisticUpdate",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetLightClientOptimisticUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLightClientOptimisticUpdate",
			OperationSummary: "Get the latest known `LightClientOptimisticUpdate`",
			OperationID:      "getLightClientOptimisticUpdate",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetLightClientOptimisticUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLightClientOptimisticUpdate(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLightClientOptimisticUpdate(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLightClientOptimisticUpdateResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLightClientUpdatesByRangeRequest handles getLightClientUpdatesByRange operation.
//
// Requests the [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/v1.3.
// 0/specs/altair/light-client/sync-protocol.md#lightclientupdate) instances in the sync committee
// period range `[start_period, start_period + count)`, leading up to the current head sync committee
// period as selected by fork choice.
// Depending on the `Accept` header they can be returned either as JSON or SSZ-serialized bytes.
// Servers SHOULD provide results as defined in [`create_light_client_update`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/full-node.
// md#create_light_client_update). They MUST respond with at least the earliest known result within
// the requested range, and MUST send results in consecutive order (by period). The response MUST NOT
// contain more than [`min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)`](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/light-client/p2p-interface.md#configuration)
// results.
//
// GET /eth/v1/beacon/light_client/updates
func (s *Server) handleGetLightClientUpdatesByRangeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLightClientUpdatesByRange"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/light_client/updates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetLightClientUpdatesByRange",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLightClientUpdatesByRange",
			ID:   "getLightClientUpdatesByRange",
		}
	)
	params, err := decodeGetLightClientUpdatesByRangeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLightClientUpdatesByRangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLightClientUpdatesByRange",
			OperationSummary: "Get `LightClientUpdate` instances in a requested sync committee period range",
			OperationID:      "getLightClientUpdatesByRange",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "start_period",
					In:   "query",
				}: params.StartPeriod,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLightClientUpdatesByRangeParams
			Response = GetLightClientUpdatesByRangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLightClientUpdatesByRangeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLightClientUpdatesByRange(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLightClientUpdatesByRange(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLightClientUpdatesByRangeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLivenessRequest handles getLiveness operation.
//
// Requests the beacon node to indicate if a validator has been observed to be live in a given epoch.
// The beacon node might detect liveness by observing messages from the validator on the network, in
// the beacon chain, from its API or from any other source. A beacon node SHOULD support the current
// and previous epoch, however it MAY support earlier epoch. It is important to note that the values
// returned by the beacon node are not canonical; they are best-effort and based upon a subjective
// view of the network. A beacon node that was recently started or suffered a network partition may
// indicate that a validator is not live when it actually is.
//
// POST /eth/v1/validator/liveness/{epoch}
func (s *Server) handleGetLivenessRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLiveness"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/liveness/{epoch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetLiveness",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLiveness",
			ID:   "getLiveness",
		}
	)
	params, err := decodeGetLivenessParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetLivenessRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetLivenessRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLiveness",
			OperationSummary: "Indicates if a validator has been observed on the network",
			OperationID:      "getLiveness",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "epoch",
					In:   "path",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GetLivenessParams
			Response = GetLivenessRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLivenessParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLiveness(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLiveness(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLivenessResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNetworkIdentityRequest handles getNetworkIdentity operation.
//
// Retrieves data about the node's network presence.
//
// GET /eth/v1/node/identity
func (s *Server) handleGetNetworkIdentityRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNetworkIdentity"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/identity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNetworkIdentity",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetNetworkIdentityRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNetworkIdentity",
			OperationSummary: "Get node network identity",
			OperationID:      "getNetworkIdentity",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNetworkIdentityRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNetworkIdentity(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNetworkIdentity(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNetworkIdentityResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNextWithdrawalsRequest handles getNextWithdrawals operation.
//
// Get the withdrawals computed from the specified state, that will be included in the block
// that gets built on the specified state.
//
// GET /eth/v1/builder/states/{state_id}/expected_withdrawals
func (s *Server) handleGetNextWithdrawalsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNextWithdrawals"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/builder/states/{state_id}/expected_withdrawals"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNextWithdrawals",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetNextWithdrawals",
			ID:   "getNextWithdrawals",
		}
	)
	params, err := decodeGetNextWithdrawalsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetNextWithdrawalsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNextWithdrawals",
			OperationSummary: "Get the withdrawals that are to be included for the block built on the specified state.",
			OperationID:      "getNextWithdrawals",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "proposal_slot",
					In:   "query",
				}: params.ProposalSlot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetNextWithdrawalsParams
			Response = GetNextWithdrawalsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetNextWithdrawalsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNextWithdrawals(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNextWithdrawals(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNextWithdrawalsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetNodeVersionRequest handles getNodeVersion operation.
//
// Requests that the beacon node identify information about its implementation in a format similar to
// a  [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
//
// GET /eth/v1/node/version
func (s *Server) handleGetNodeVersionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getNodeVersion"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/version"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetNodeVersion",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetNodeVersionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetNodeVersion",
			OperationSummary: "Get version string of the running beacon node.",
			OperationID:      "getNodeVersion",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetNodeVersionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetNodeVersion(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetNodeVersion(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetNodeVersionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPeerRequest handles getPeer operation.
//
// Retrieves data about the given peer.
//
// GET /eth/v1/node/peers/{peer_id}
func (s *Server) handleGetPeerRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeer"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peers/{peer_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPeer",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPeer",
			ID:   "getPeer",
		}
	)
	params, err := decodeGetPeerParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPeerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPeer",
			OperationSummary: "Get peer",
			OperationID:      "getPeer",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "peer_id",
					In:   "path",
				}: params.PeerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPeerParams
			Response = GetPeerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPeerParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPeer(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPeer(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPeerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPeerCountRequest handles getPeerCount operation.
//
// Retrieves number of known peers.
//
// GET /eth/v1/node/peer_count
func (s *Server) handleGetPeerCountRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeerCount"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peer_count"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPeerCount",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetPeerCountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPeerCount",
			OperationSummary: "Get peer count",
			OperationID:      "getPeerCount",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPeerCountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPeerCount(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPeerCount(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPeerCountResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPeersRequest handles getPeers operation.
//
// Retrieves data about the node's network peers. By default this returns all peers. Multiple query
// params are combined using AND conditions.
//
// GET /eth/v1/node/peers
func (s *Server) handleGetPeersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPeers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/peers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPeers",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPeers",
			ID:   "getPeers",
		}
	)
	params, err := decodeGetPeersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPeersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPeers",
			OperationSummary: "Get node network peers",
			OperationID:      "getPeers",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPeersParams
			Response = GetPeersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPeersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPeers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPeers(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPeersResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPoolAttestationsRequest handles getPoolAttestations operation.
//
// Retrieves attestations known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attestations
func (s *Server) handleGetPoolAttestationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolAttestations"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attestations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPoolAttestations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetPoolAttestations",
			ID:   "getPoolAttestations",
		}
	)
	params, err := decodeGetPoolAttestationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetPoolAttestationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPoolAttestations",
			OperationSummary: "Get Attestations from operations pool",
			OperationID:      "getPoolAttestations",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
				{
					Name: "committee_index",
					In:   "query",
				}: params.CommitteeIndex,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPoolAttestationsParams
			Response = GetPoolAttestationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPoolAttestationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPoolAttestations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPoolAttestations(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPoolAttestationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPoolAttesterSlashingsRequest handles getPoolAttesterSlashings operation.
//
// Retrieves attester slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/attester_slashings
func (s *Server) handleGetPoolAttesterSlashingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolAttesterSlashings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attester_slashings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPoolAttesterSlashings",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetPoolAttesterSlashingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPoolAttesterSlashings",
			OperationSummary: "Get AttesterSlashings from operations pool",
			OperationID:      "getPoolAttesterSlashings",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPoolAttesterSlashingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPoolAttesterSlashings(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPoolAttesterSlashings(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPoolAttesterSlashingsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPoolBLSToExecutionChangesRequest handles getPoolBLSToExecutionChanges operation.
//
// Retrieves BLS to execution changes known by the node but not necessarily incorporated into any
// block.
//
// GET /eth/v1/beacon/pool/bls_to_execution_changes
func (s *Server) handleGetPoolBLSToExecutionChangesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolBLSToExecutionChanges"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/bls_to_execution_changes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPoolBLSToExecutionChanges",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetPoolBLSToExecutionChangesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPoolBLSToExecutionChanges",
			OperationSummary: "Get SignedBLSToExecutionChange from operations pool",
			OperationID:      "getPoolBLSToExecutionChanges",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPoolBLSToExecutionChangesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPoolBLSToExecutionChanges(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPoolBLSToExecutionChanges(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPoolBLSToExecutionChangesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPoolProposerSlashingsRequest handles getPoolProposerSlashings operation.
//
// Retrieves proposer slashings known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/proposer_slashings
func (s *Server) handleGetPoolProposerSlashingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolProposerSlashings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/proposer_slashings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPoolProposerSlashings",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetPoolProposerSlashingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPoolProposerSlashings",
			OperationSummary: "Get ProposerSlashings from operations pool",
			OperationID:      "getPoolProposerSlashings",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPoolProposerSlashingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPoolProposerSlashings(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPoolProposerSlashings(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPoolProposerSlashingsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPoolVoluntaryExitsRequest handles getPoolVoluntaryExits operation.
//
// Retrieves voluntary exits known by the node but not necessarily incorporated into any block.
//
// GET /eth/v1/beacon/pool/voluntary_exits
func (s *Server) handleGetPoolVoluntaryExitsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPoolVoluntaryExits"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/voluntary_exits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetPoolVoluntaryExits",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetPoolVoluntaryExitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetPoolVoluntaryExits",
			OperationSummary: "Get SignedVoluntaryExit from operations pool",
			OperationID:      "getPoolVoluntaryExits",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetPoolVoluntaryExitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPoolVoluntaryExits(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPoolVoluntaryExits(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPoolVoluntaryExitsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProposerDutiesRequest handles getProposerDuties operation.
//
// Request beacon node to provide all validators that are scheduled to propose a block in the given
// epoch.
// Duties should only need to be checked once per epoch, however a chain reorganization could occur
// that results in a change of duties. For full safety, you should monitor head events and confirm
// the dependent root in this response matches:
// - event.current_duty_dependent_root when `compute_epoch_at_slot(event.slot) == epoch`
// - event.block otherwise
// The dependent_root value is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) -
// 1)` or the genesis block root in the case of underflow.
//
// GET /eth/v1/validator/duties/proposer/{epoch}
func (s *Server) handleGetProposerDutiesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProposerDuties"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/proposer/{epoch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetProposerDuties",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetProposerDuties",
			ID:   "getProposerDuties",
		}
	)
	params, err := decodeGetProposerDutiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetProposerDutiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProposerDuties",
			OperationSummary: "Get block proposers duties",
			OperationID:      "getProposerDuties",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "epoch",
					In:   "path",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetProposerDutiesParams
			Response = GetProposerDutiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetProposerDutiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProposerDuties(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProposerDuties(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProposerDutiesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSpecRequest handles getSpec operation.
//
// Retrieve specification configuration used on this node.  The configuration should include:
// - Constants for all hard forks known by the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.md#constants) and
// [altair](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/altair/beacon-chain.
// md#constants) values
// - Presets for all hard forks supplied to the beacon node, for example the [phase 0](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/phase0.yaml) and [altair](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/presets/mainnet/altair.yaml) values
// - Configuration for the beacon node, for example the [mainnet](https://github.
// com/ethereum/consensus-specs/blob/v1.3.0/configs/mainnet.yaml) values
// Values are returned with following format:
// - any value starting with 0x in the spec is returned as a hex string
// - numeric values are returned as a quoted integer.
//
// GET /eth/v1/config/spec
func (s *Server) handleGetSpecRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpec"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/config/spec"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSpec",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetSpecRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSpec",
			OperationSummary: "Get spec params.",
			OperationID:      "getSpec",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSpecRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSpec(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSpec(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSpecResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateFinalityCheckpointsRequest handles getStateFinalityCheckpoints operation.
//
// Returns finality checkpoints for state with given 'stateId'.
// In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
//
// GET /eth/v1/beacon/states/{state_id}/finality_checkpoints
func (s *Server) handleGetStateFinalityCheckpointsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateFinalityCheckpoints"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/finality_checkpoints"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateFinalityCheckpoints",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateFinalityCheckpoints",
			ID:   "getStateFinalityCheckpoints",
		}
	)
	params, err := decodeGetStateFinalityCheckpointsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateFinalityCheckpointsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateFinalityCheckpoints",
			OperationSummary: "Get state finality checkpoints",
			OperationID:      "getStateFinalityCheckpoints",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateFinalityCheckpointsParams
			Response = GetStateFinalityCheckpointsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateFinalityCheckpointsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateFinalityCheckpoints(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateFinalityCheckpoints(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateFinalityCheckpointsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateForkRequest handles getStateFork operation.
//
// Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/beacon-chain.
// md#fork) object for state with given 'stateId'.
//
// GET /eth/v1/beacon/states/{state_id}/fork
func (s *Server) handleGetStateForkRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateFork"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/fork"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateFork",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateFork",
			ID:   "getStateFork",
		}
	)
	params, err := decodeGetStateForkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateFork",
			OperationSummary: "Get Fork object for requested state",
			OperationID:      "getStateFork",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateForkParams
			Response = GetStateForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateForkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateFork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateFork(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateForkResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateRandaoRequest handles getStateRandao operation.
//
// Fetch the RANDAO mix for the requested epoch from the state identified by `state_id`.
// If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.
// By adjusting the `state_id` parameter you can query for any historic value of the RANDAO mix.
// Ordinarily states from the same epoch will mutate the RANDAO mix for that epoch as blocks are
// applied.
//
// GET /eth/v1/beacon/states/{state_id}/randao
func (s *Server) handleGetStateRandaoRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateRandao"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/randao"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateRandao",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateRandao",
			ID:   "getStateRandao",
		}
	)
	params, err := decodeGetStateRandaoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateRandaoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateRandao",
			OperationSummary: "Get the RANDAO mix for some epoch in a specified state.",
			OperationID:      "getStateRandao",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "epoch",
					In:   "query",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateRandaoParams
			Response = GetStateRandaoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateRandaoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateRandao(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateRandao(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateRandaoResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateRootRequest handles getStateRoot operation.
//
// Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be
// returned.
//
// GET /eth/v1/beacon/states/{state_id}/root
func (s *Server) handleGetStateRootRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateRoot"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/root"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateRoot",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateRoot",
			ID:   "getStateRoot",
		}
	)
	params, err := decodeGetStateRootParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateRootRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateRoot",
			OperationSummary: "Get state SSZ HashTreeRoot",
			OperationID:      "getStateRoot",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateRootParams
			Response = GetStateRootRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateRootParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateRoot(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateRoot(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateRootResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateV2Request handles getStateV2 operation.
//
// Returns full BeaconState object for given stateId.
// Depending on `Accept` header it can be returned either as json or as bytes serialized by SSZ.
//
// GET /eth/v2/debug/beacon/states/{state_id}
func (s *Server) handleGetStateV2Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/debug/beacon/states/{state_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateV2",
			ID:   "getStateV2",
		}
	)
	params, err := decodeGetStateV2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateV2",
			OperationSummary: "Get full BeaconState object",
			OperationID:      "getStateV2",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateV2Params
			Response = GetStateV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateV2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateV2(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateV2(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateValidatorRequest handles getStateValidator operation.
//
// Returns validator specified by state and id or public key along with status and balance.
//
// GET /eth/v1/beacon/states/{state_id}/validators/{validator_id}
func (s *Server) handleGetStateValidatorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidator"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validators/{validator_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateValidator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateValidator",
			ID:   "getStateValidator",
		}
	)
	params, err := decodeGetStateValidatorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateValidatorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateValidator",
			OperationSummary: "Get validator from state by id",
			OperationID:      "getStateValidator",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "validator_id",
					In:   "path",
				}: params.ValidatorID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateValidatorParams
			Response = GetStateValidatorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateValidatorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateValidator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateValidator(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateValidatorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateValidatorBalancesRequest handles getStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validator_balances
func (s *Server) handleGetStateValidatorBalancesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidatorBalances"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validator_balances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateValidatorBalances",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateValidatorBalances",
			ID:   "getStateValidatorBalances",
		}
	)
	params, err := decodeGetStateValidatorBalancesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateValidatorBalancesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateValidatorBalances",
			OperationSummary: "Get validator balances from state",
			OperationID:      "getStateValidatorBalances",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "id",
					In:   "query",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateValidatorBalancesParams
			Response = GetStateValidatorBalancesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateValidatorBalancesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateValidatorBalances(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateValidatorBalances(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateValidatorBalancesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStateValidatorsRequest handles getStateValidators operation.
//
// Returns filterable list of validators with their balance, status and index.
// Information will be returned for all indices or public key that match known validators.  If an
// index or public key does not
// match any known validator, no information will be returned but this will not cause an error.
// There are no guarantees for the
// returned data in terms of ordering; both the index and public key are returned for each validator,
// and can be used to confirm
// for which inputs a response has been returned.
//
// GET /eth/v1/beacon/states/{state_id}/validators
func (s *Server) handleGetStateValidatorsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStateValidators"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetStateValidators",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetStateValidators",
			ID:   "getStateValidators",
		}
	)
	params, err := decodeGetStateValidatorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetStateValidatorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetStateValidators",
			OperationSummary: "Get validators from state",
			OperationID:      "getStateValidators",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
				{
					Name: "id",
					In:   "query",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStateValidatorsParams
			Response = GetStateValidatorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStateValidatorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStateValidators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStateValidators(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetStateValidatorsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSyncCommitteeDutiesRequest handles getSyncCommitteeDuties operation.
//
// Requests the beacon node to provide a set of sync committee duties for a particular epoch.
//
// POST /eth/v1/validator/duties/sync/{epoch}
func (s *Server) handleGetSyncCommitteeDutiesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncCommitteeDuties"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/duties/sync/{epoch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSyncCommitteeDuties",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSyncCommitteeDuties",
			ID:   "getSyncCommitteeDuties",
		}
	)
	params, err := decodeGetSyncCommitteeDutiesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetSyncCommitteeDutiesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetSyncCommitteeDutiesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSyncCommitteeDuties",
			OperationSummary: "Get sync committee duties",
			OperationID:      "getSyncCommitteeDuties",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "epoch",
					In:   "path",
				}: params.Epoch,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GetSyncCommitteeDutiesParams
			Response = GetSyncCommitteeDutiesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSyncCommitteeDutiesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSyncCommitteeDuties(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSyncCommitteeDuties(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSyncCommitteeDutiesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSyncCommitteeRewardsRequest handles getSyncCommitteeRewards operation.
//
// Retrieves rewards info for sync committee members specified by array of public keys or validator
// index. If no array is provided, return reward info for every committee member.
//
// POST /eth/v1/beacon/rewards/sync_committee/{block_id}
func (s *Server) handleGetSyncCommitteeRewardsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncCommitteeRewards"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/rewards/sync_committee/{block_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSyncCommitteeRewards",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetSyncCommitteeRewards",
			ID:   "getSyncCommitteeRewards",
		}
	)
	params, err := decodeGetSyncCommitteeRewardsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGetSyncCommitteeRewardsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GetSyncCommitteeRewardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSyncCommitteeRewards",
			OperationSummary: "Get sync committee rewards",
			OperationID:      "getSyncCommitteeRewards",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "block_id",
					In:   "path",
				}: params.BlockID,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GetSyncCommitteeRewardsParams
			Response = GetSyncCommitteeRewardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSyncCommitteeRewardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSyncCommitteeRewards(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSyncCommitteeRewards(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSyncCommitteeRewardsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSyncingStatusRequest handles getSyncingStatus operation.
//
// Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it
// is up to.
//
// GET /eth/v1/node/syncing
func (s *Server) handleGetSyncingStatusRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSyncingStatus"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/node/syncing"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GetSyncingStatus",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response GetSyncingStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetSyncingStatus",
			OperationSummary: "Get node syncing status",
			OperationID:      "getSyncingStatus",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetSyncingStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSyncingStatus(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSyncingStatus(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSyncingStatusResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostStateValidatorBalancesRequest handles postStateValidatorBalances operation.
//
// Returns filterable list of validators balances.
// Balances will be returned for all indices or public key that match known validators. If an index
// or public key does not
// match any known validator, no balance will be returned but this will not cause an error. There are
// no guarantees for the
// returned data in terms of ordering; the index is returned for each balance, and can be used to
// confirm for which inputs a
// response has been returned.
//
// POST /eth/v1/beacon/states/{state_id}/validator_balances
func (s *Server) handlePostStateValidatorBalancesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("postStateValidatorBalances"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/states/{state_id}/validator_balances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PostStateValidatorBalances",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostStateValidatorBalances",
			ID:   "postStateValidatorBalances",
		}
	)
	params, err := decodePostStateValidatorBalancesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostStateValidatorBalancesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostStateValidatorBalancesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostStateValidatorBalances",
			OperationSummary: "Get validator balances from state",
			OperationID:      "postStateValidatorBalances",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "state_id",
					In:   "path",
				}: params.StateID,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = PostStateValidatorBalancesParams
			Response = PostStateValidatorBalancesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostStateValidatorBalancesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostStateValidatorBalances(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostStateValidatorBalances(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostStateValidatorBalancesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePrepareBeaconCommitteeSubnetRequest handles prepareBeaconCommitteeSubnet operation.
//
// After beacon node receives this request,
// search using discv5 for peers related to this subnet
// and replace current peers with those ones if necessary
// If validator `is_aggregator`, beacon node must:
// - announce subnet topic subscription on gossipsub
// - aggregate attestations received on that subnet.
//
// POST /eth/v1/validator/beacon_committee_subscriptions
func (s *Server) handlePrepareBeaconCommitteeSubnetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareBeaconCommitteeSubnet"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/beacon_committee_subscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PrepareBeaconCommitteeSubnet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PrepareBeaconCommitteeSubnet",
			ID:   "prepareBeaconCommitteeSubnet",
		}
	)
	request, close, err := s.decodePrepareBeaconCommitteeSubnetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PrepareBeaconCommitteeSubnetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PrepareBeaconCommitteeSubnet",
			OperationSummary: "Signal beacon node to prepare for a committee subnet",
			OperationID:      "prepareBeaconCommitteeSubnet",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []PrepareBeaconCommitteeSubnetReqItem
			Params   = struct{}
			Response = PrepareBeaconCommitteeSubnetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PrepareBeaconCommitteeSubnet(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PrepareBeaconCommitteeSubnet(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePrepareBeaconCommitteeSubnetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePrepareBeaconProposerRequest handles prepareBeaconProposer operation.
//
// Prepares the beacon node for potential proposers by supplying information
// required when proposing blocks for the given validators.  The information
// supplied for each validator index will persist through the epoch in which
// the call is submitted and for a further two epochs after that, or until the
// beacon node restarts.  It is expected that validator clients will send this
// information periodically, for example each epoch, to ensure beacon nodes have
// correct and timely fee recipient information.
// Note that there is no guarantee that the beacon node will use the supplied fee
// recipient when creating a block proposal, so on receipt of a proposed block the
// validator should confirm that it finds the fee recipient within the block
// acceptable before signing it.
// Also note that requests containing currently inactive or unknown validator
// indices will be accepted, as they may become active at a later epoch.
//
// POST /eth/v1/validator/prepare_beacon_proposer
func (s *Server) handlePrepareBeaconProposerRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareBeaconProposer"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/prepare_beacon_proposer"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PrepareBeaconProposer",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PrepareBeaconProposer",
			ID:   "prepareBeaconProposer",
		}
	)
	request, close, err := s.decodePrepareBeaconProposerRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PrepareBeaconProposerRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PrepareBeaconProposer",
			OperationSummary: "Provide beacon node with proposals for the given validators.",
			OperationID:      "prepareBeaconProposer",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []PrepareBeaconProposerReqItem
			Params   = struct{}
			Response = PrepareBeaconProposerRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PrepareBeaconProposer(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PrepareBeaconProposer(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePrepareBeaconProposerResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePrepareSyncCommitteeSubnetsRequest handles prepareSyncCommitteeSubnets operation.
//
// Subscribe to a number of sync committee subnets
// Sync committees are not present in phase0, but are required for Altair networks.
// Subscribing to sync committee subnets is an action performed by VC to enable network participation
// in Altair networks, and only required if the VC has an active validator in an active sync
// committee.
//
// POST /eth/v1/validator/sync_committee_subscriptions
func (s *Server) handlePrepareSyncCommitteeSubnetsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("prepareSyncCommitteeSubnets"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_subscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PrepareSyncCommitteeSubnets",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PrepareSyncCommitteeSubnets",
			ID:   "prepareSyncCommitteeSubnets",
		}
	)
	request, close, err := s.decodePrepareSyncCommitteeSubnetsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PrepareSyncCommitteeSubnetsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PrepareSyncCommitteeSubnets",
			OperationSummary: "Subscribe to sync committee subnets",
			OperationID:      "prepareSyncCommitteeSubnets",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []PrepareSyncCommitteeSubnetsReqItem
			Params   = struct{}
			Response = PrepareSyncCommitteeSubnetsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PrepareSyncCommitteeSubnets(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PrepareSyncCommitteeSubnets(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePrepareSyncCommitteeSubnetsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProduceAttestationDataRequest handles produceAttestationData operation.
//
// Requests that the beacon node produce an AttestationData.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the attestation attests to a block
// that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/attestation_data
func (s *Server) handleProduceAttestationDataRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceAttestationData"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/attestation_data"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProduceAttestationData",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProduceAttestationData",
			ID:   "produceAttestationData",
		}
	)
	params, err := decodeProduceAttestationDataParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProduceAttestationDataRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ProduceAttestationData",
			OperationSummary: "Produce an attestation data",
			OperationID:      "produceAttestationData",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
				{
					Name: "committee_index",
					In:   "query",
				}: params.CommitteeIndex,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProduceAttestationDataParams
			Response = ProduceAttestationDataRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProduceAttestationDataParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProduceAttestationData(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProduceAttestationData(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProduceAttestationDataResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProduceBlindedBlockRequest handles produceBlindedBlock operation.
//
// Requests a beacon node to produce a valid blinded block, which can then be signed by a validator.
// A blinded block is a block with only a transactions root, rather than a full transactions list.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
// Before Bellatrix, this endpoint will return a `BeaconBlock`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v1/validator/blinded_blocks/{slot}
func (s *Server) handleProduceBlindedBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlindedBlock"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/blinded_blocks/{slot}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProduceBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProduceBlindedBlock",
			ID:   "produceBlindedBlock",
		}
	)
	params, err := decodeProduceBlindedBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProduceBlindedBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ProduceBlindedBlock",
			OperationSummary: "Produce a new blinded block, without signature.",
			OperationID:      "produceBlindedBlock",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "path",
				}: params.Slot,
				{
					Name: "randao_reveal",
					In:   "query",
				}: params.RandaoReveal,
				{
					Name: "graffiti",
					In:   "query",
				}: params.Graffiti,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProduceBlindedBlockParams
			Response = ProduceBlindedBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProduceBlindedBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProduceBlindedBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProduceBlindedBlock(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProduceBlindedBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProduceBlockV2Request handles produceBlockV2 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /eth/v2/validator/blocks/{slot}
func (s *Server) handleProduceBlockV2Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlockV2"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v2/validator/blocks/{slot}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProduceBlockV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProduceBlockV2",
			ID:   "produceBlockV2",
		}
	)
	params, err := decodeProduceBlockV2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProduceBlockV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ProduceBlockV2",
			OperationSummary: "Produce a new block, without signature.",
			OperationID:      "produceBlockV2",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "path",
				}: params.Slot,
				{
					Name: "randao_reveal",
					In:   "query",
				}: params.RandaoReveal,
				{
					Name: "graffiti",
					In:   "query",
				}: params.Graffiti,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProduceBlockV2Params
			Response = ProduceBlockV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProduceBlockV2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProduceBlockV2(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProduceBlockV2(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProduceBlockV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProduceBlockV3Request handles produceBlockV3 operation.
//
// Requests a beacon node to produce a valid block, which can then be signed by a validator. The
// returned block may be blinded or unblinded, depending on the current state of the network as
// decided by the execution and beacon nodes.
// The beacon node must return an unblinded block if it obtains the execution payload from its
// paired execution node. It must only return a blinded block if it obtains the execution payload
// header from an MEV relay.
// Metadata in the response indicates the type of block produced, and the supported types of block
// will be added to as forks progress.
//
// GET /eth/v3/validator/blocks/{slot}
func (s *Server) handleProduceBlockV3Request(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceBlockV3"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v3/validator/blocks/{slot}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProduceBlockV3",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProduceBlockV3",
			ID:   "produceBlockV3",
		}
	)
	params, err := decodeProduceBlockV3Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProduceBlockV3Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ProduceBlockV3",
			OperationSummary: "Produce a new block, without signature.",
			OperationID:      "produceBlockV3",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "path",
				}: params.Slot,
				{
					Name: "randao_reveal",
					In:   "query",
				}: params.RandaoReveal,
				{
					Name: "graffiti",
					In:   "query",
				}: params.Graffiti,
				{
					Name: "builder_boost_factor",
					In:   "query",
				}: params.BuilderBoostFactor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProduceBlockV3Params
			Response = ProduceBlockV3Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProduceBlockV3Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProduceBlockV3(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProduceBlockV3(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProduceBlockV3Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProduceSyncCommitteeContributionRequest handles produceSyncCommitteeContribution operation.
//
// Requests that the beacon node produce a sync committee contribution.
// A 503 error must be returned if the block identified by the response
// `beacon_block_root` is optimistic (i.e. the sync committee contribution
// refers to a block that has not been fully verified by an execution engine).
//
// GET /eth/v1/validator/sync_committee_contribution
func (s *Server) handleProduceSyncCommitteeContributionRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("produceSyncCommitteeContribution"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_contribution"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProduceSyncCommitteeContribution",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProduceSyncCommitteeContribution",
			ID:   "produceSyncCommitteeContribution",
		}
	)
	params, err := decodeProduceSyncCommitteeContributionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response ProduceSyncCommitteeContributionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "ProduceSyncCommitteeContribution",
			OperationSummary: "Produce a sync committee contribution",
			OperationID:      "produceSyncCommitteeContribution",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "slot",
					In:   "query",
				}: params.Slot,
				{
					Name: "subcommittee_index",
					In:   "query",
				}: params.SubcommitteeIndex,
				{
					Name: "beacon_block_root",
					In:   "query",
				}: params.BeaconBlockRoot,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProduceSyncCommitteeContributionParams
			Response = ProduceSyncCommitteeContributionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProduceSyncCommitteeContributionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProduceSyncCommitteeContribution(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProduceSyncCommitteeContribution(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProduceSyncCommitteeContributionResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishAggregateAndProofsRequest handles publishAggregateAndProofs operation.
//
// Verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
//
// POST /eth/v1/validator/aggregate_and_proofs
func (s *Server) handlePublishAggregateAndProofsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishAggregateAndProofs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/aggregate_and_proofs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishAggregateAndProofs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishAggregateAndProofs",
			ID:   "publishAggregateAndProofs",
		}
	)
	request, close, err := s.decodePublishAggregateAndProofsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishAggregateAndProofsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishAggregateAndProofs",
			OperationSummary: "Publish multiple aggregate and proofs",
			OperationID:      "publishAggregateAndProofs",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []PublishAggregateAndProofsReqItem
			Params   = struct{}
			Response = PublishAggregateAndProofsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishAggregateAndProofs(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishAggregateAndProofs(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishAggregateAndProofsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishBlindedBlockRequest handles publishBlindedBlock operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`.
//
// POST /eth/v1/beacon/blinded_blocks
func (s *Server) handlePublishBlindedBlockRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlindedBlock"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blinded_blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishBlindedBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishBlindedBlock",
			ID:   "publishBlindedBlock",
		}
	)
	params, err := decodePublishBlindedBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePublishBlindedBlockRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishBlindedBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishBlindedBlock",
			OperationSummary: "Publish a signed block.",
			OperationID:      "publishBlindedBlock",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "Eth-Consensus-Version",
					In:   "header",
				}: params.EthConsensusVersion,
			},
			Raw: r,
		}

		type (
			Request  = PublishBlindedBlockReqApplicationOctetStream
			Params   = PublishBlindedBlockParams
			Response = PublishBlindedBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPublishBlindedBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishBlindedBlock(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishBlindedBlock(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishBlindedBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishBlindedBlockV2Request handles publishBlindedBlockV2 operation.
//
// Instructs the beacon node to use the components of the `SignedBlindedBeaconBlock` to construct and
// publish a
// `SignedBeaconBlock` by swapping out the `transactions_root` for the corresponding full list of
// `transactions`.
// The beacon node should broadcast a newly constructed `SignedBeaconBlock` to the beacon network,
// to be included in the beacon chain. The beacon node is not required to validate the signed
// `BeaconBlock`, and a successful response (20X) only indicates that the broadcast has been
// successful. The beacon node is expected to integrate the new block into its state, and
// therefore validate the block internally, however blocks which fail the validation are still
// broadcast but a different status code is returned (202). Before Bellatrix, this endpoint will
// accept
// a `SignedBeaconBlock`. The broadcast behaviour may be adjusted via the `broadcast_validation`
// query parameter.
//
// POST /eth/v2/beacon/blinded_blocks
func (s *Server) handlePublishBlindedBlockV2Request(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlindedBlockV2"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blinded_blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishBlindedBlockV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishBlindedBlockV2",
			ID:   "publishBlindedBlockV2",
		}
	)
	params, err := decodePublishBlindedBlockV2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePublishBlindedBlockV2Request(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishBlindedBlockV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishBlindedBlockV2",
			OperationSummary: "Publish a signed block.",
			OperationID:      "publishBlindedBlockV2",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "broadcast_validation",
					In:   "query",
				}: params.BroadcastValidation,
				{
					Name: "Eth-Consensus-Version",
					In:   "header",
				}: params.EthConsensusVersion,
			},
			Raw: r,
		}

		type (
			Request  = PublishBlindedBlockV2ReqApplicationOctetStream
			Params   = PublishBlindedBlockV2Params
			Response = PublishBlindedBlockV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPublishBlindedBlockV2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishBlindedBlockV2(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishBlindedBlockV2(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishBlindedBlockV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishBlockRequest handles publishBlock operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs.
//
// POST /eth/v1/beacon/blocks
func (s *Server) handlePublishBlockRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlock"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishBlock",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishBlock",
			ID:   "publishBlock",
		}
	)
	params, err := decodePublishBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePublishBlockRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishBlock",
			OperationSummary: "Publish a signed block.",
			OperationID:      "publishBlock",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "Eth-Consensus-Version",
					In:   "header",
				}: params.EthConsensusVersion,
			},
			Raw: r,
		}

		type (
			Request  = PublishBlockReqApplicationOctetStream
			Params   = PublishBlockParams
			Response = PublishBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPublishBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishBlock(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishBlock(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishBlockResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishBlockV2Request handles publishBlockV2 operation.
//
// Instructs the beacon node to broadcast a newly signed beacon block to the beacon network,
// to be included in the beacon chain. A success response (20x) indicates that the block
// passed gossip validation and was successfully broadcast onto the network.
// The beacon node is also expected to integrate the block into the state, but may broadcast it
// before doing so, so as to aid timely delivery of the block. Should the block fail full
// validation, a separate success response code (202) is used to indicate that the block was
// successfully broadcast but failed integration. After Deneb, this additionally instructs
// the beacon node to broadcast all given blobs. The broadcast behaviour may be adjusted via the
// `broadcast_validation` query parameter.
//
// POST /eth/v2/beacon/blocks
func (s *Server) handlePublishBlockV2Request(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishBlockV2"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v2/beacon/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishBlockV2",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishBlockV2",
			ID:   "publishBlockV2",
		}
	)
	params, err := decodePublishBlockV2Params(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePublishBlockV2Request(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishBlockV2Res
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishBlockV2",
			OperationSummary: "Publish a signed block.",
			OperationID:      "publishBlockV2",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "broadcast_validation",
					In:   "query",
				}: params.BroadcastValidation,
				{
					Name: "Eth-Consensus-Version",
					In:   "header",
				}: params.EthConsensusVersion,
			},
			Raw: r,
		}

		type (
			Request  = PublishBlockV2ReqApplicationOctetStream
			Params   = PublishBlockV2Params
			Response = PublishBlockV2Res
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPublishBlockV2Params,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishBlockV2(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishBlockV2(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishBlockV2Response(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePublishContributionAndProofsRequest handles publishContributionAndProofs operation.
//
// Publish multiple signed sync committee contribution and proofs.
//
// POST /eth/v1/validator/contribution_and_proofs
func (s *Server) handlePublishContributionAndProofsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("publishContributionAndProofs"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/contribution_and_proofs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PublishContributionAndProofs",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PublishContributionAndProofs",
			ID:   "publishContributionAndProofs",
		}
	)
	request, close, err := s.decodePublishContributionAndProofsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PublishContributionAndProofsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PublishContributionAndProofs",
			OperationSummary: "Publish multiple contribution and proofs",
			OperationID:      "publishContributionAndProofs",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []PublishContributionAndProofsReqItem
			Params   = struct{}
			Response = PublishContributionAndProofsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PublishContributionAndProofs(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PublishContributionAndProofs(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePublishContributionAndProofsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRegisterValidatorRequest handles registerValidator operation.
//
// Prepares the beacon node for engaging with external builders. The
// information must be sent by the beacon node to the builder network. It is
// expected that the validator client will send this information periodically
// to ensure the beacon node has correct and timely registration information
// to provide to builders. The validator client should not sign blinded beacon
// blocks that do not adhere to their latest fee recipient and gas limit
// preferences.
// Note that only registrations for active or pending validators must be sent to the builder network.
// Registrations for unknown or exited validators must be filtered out and not sent to the builder
// network.
//
// POST /eth/v1/validator/register_validator
func (s *Server) handleRegisterValidatorRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("registerValidator"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/register_validator"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RegisterValidator",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RegisterValidator",
			ID:   "registerValidator",
		}
	)
	request, close, err := s.decodeRegisterValidatorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response RegisterValidatorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "RegisterValidator",
			OperationSummary: "Provide beacon node with registrations for the given validators to the external builder network.",
			OperationID:      "registerValidator",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []RegisterValidatorReqItem
			Params   = struct{}
			Response = RegisterValidatorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RegisterValidator(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.RegisterValidator(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRegisterValidatorResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitBeaconCommitteeSelectionsRequest handles submitBeaconCommitteeSelections operation.
//
// This endpoint should be used by a validator client running as part of a distributed validator
// cluster, and is
// implemented by a distributed validator middleware client. This endpoint is used to exchange partial
// selection proofs for combined/aggregated selection proofs to allow a validator client
// to correctly determine if any of its validators has been selected to perform an attestation
// aggregation duty in a slot.
// Validator clients running in a distributed validator cluster must query this endpoint at the start
// of an epoch for the current and lookahead (next) epochs for
// all validators that have attester duties in the current and lookahead epochs. Consensus clients
// need not support this
// endpoint and may return a 501.
//
// POST /eth/v1/validator/beacon_committee_selections
func (s *Server) handleSubmitBeaconCommitteeSelectionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitBeaconCommitteeSelections"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/beacon_committee_selections"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitBeaconCommitteeSelections",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitBeaconCommitteeSelections",
			ID:   "submitBeaconCommitteeSelections",
		}
	)
	request, close, err := s.decodeSubmitBeaconCommitteeSelectionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitBeaconCommitteeSelectionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitBeaconCommitteeSelections",
			OperationSummary: "Determine if a distributed validator has been selected to aggregate attestations",
			OperationID:      "submitBeaconCommitteeSelections",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []SubmitBeaconCommitteeSelectionsReqItem
			Params   = struct{}
			Response = SubmitBeaconCommitteeSelectionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitBeaconCommitteeSelections(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitBeaconCommitteeSelections(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitBeaconCommitteeSelectionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolAttestationsRequest handles submitPoolAttestations operation.
//
// Submits Attestation objects to the node.  Each attestation in the request body is processed
// individually.
// If an attestation is validated successfully the node MUST publish that attestation on the
// appropriate subnet.
// If one or more attestations fail validation the node MUST return a 400 error with details of which
// attestations have failed, and why.
//
// POST /eth/v1/beacon/pool/attestations
func (s *Server) handleSubmitPoolAttestationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolAttestations"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attestations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolAttestations",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolAttestations",
			ID:   "submitPoolAttestations",
		}
	)
	request, close, err := s.decodeSubmitPoolAttestationsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolAttestationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolAttestations",
			OperationSummary: "Submit Attestation objects to node",
			OperationID:      "submitPoolAttestations",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []SubmitPoolAttestationsReqItem
			Params   = struct{}
			Response = SubmitPoolAttestationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolAttestations(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolAttestations(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolAttestationsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolAttesterSlashingsRequest handles submitPoolAttesterSlashings operation.
//
// Submits AttesterSlashing object to node's pool and if passes validation node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/attester_slashings
func (s *Server) handleSubmitPoolAttesterSlashingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolAttesterSlashings"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/attester_slashings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolAttesterSlashings",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolAttesterSlashings",
			ID:   "submitPoolAttesterSlashings",
		}
	)
	request, close, err := s.decodeSubmitPoolAttesterSlashingsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolAttesterSlashingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolAttesterSlashings",
			OperationSummary: "Submit AttesterSlashing object to node's pool",
			OperationID:      "submitPoolAttesterSlashings",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SubmitPoolAttesterSlashingsReq
			Params   = struct{}
			Response = SubmitPoolAttesterSlashingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolAttesterSlashings(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolAttesterSlashings(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolAttesterSlashingsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolBLSToExecutionChangeRequest handles submitPoolBLSToExecutionChange operation.
//
// Submits a list of SignedBLSToExecutionChange objects to node's pool. Any that pass validation MUST
// be broadcast to the network.
//
// POST /eth/v1/beacon/pool/bls_to_execution_changes
func (s *Server) handleSubmitPoolBLSToExecutionChangeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolBLSToExecutionChange"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/bls_to_execution_changes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolBLSToExecutionChange",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolBLSToExecutionChange",
			ID:   "submitPoolBLSToExecutionChange",
		}
	)
	request, close, err := s.decodeSubmitPoolBLSToExecutionChangeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolBLSToExecutionChangeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolBLSToExecutionChange",
			OperationSummary: "Submit SignedBLSToExecutionChange object to node's pool",
			OperationID:      "submitPoolBLSToExecutionChange",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []SubmitPoolBLSToExecutionChangeReqItem
			Params   = struct{}
			Response = SubmitPoolBLSToExecutionChangeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolBLSToExecutionChange(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolBLSToExecutionChange(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolBLSToExecutionChangeResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolProposerSlashingsRequest handles submitPoolProposerSlashings operation.
//
// Submits ProposerSlashing object to node's pool and if passes validation  node MUST broadcast it to
// network.
//
// POST /eth/v1/beacon/pool/proposer_slashings
func (s *Server) handleSubmitPoolProposerSlashingsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolProposerSlashings"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/proposer_slashings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolProposerSlashings",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolProposerSlashings",
			ID:   "submitPoolProposerSlashings",
		}
	)
	request, close, err := s.decodeSubmitPoolProposerSlashingsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolProposerSlashingsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolProposerSlashings",
			OperationSummary: "Submit ProposerSlashing object to node's pool",
			OperationID:      "submitPoolProposerSlashings",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SubmitPoolProposerSlashingsReq
			Params   = struct{}
			Response = SubmitPoolProposerSlashingsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolProposerSlashings(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolProposerSlashings(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolProposerSlashingsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolSyncCommitteeSignaturesRequest handles submitPoolSyncCommitteeSignatures operation.
//
// Submits sync committee signature objects to the node.
// Sync committee signatures are not present in phase0, but are required for Altair networks.
// If a sync committee signature is validated successfully the node MUST publish that sync committee
// signature on all applicable subnets.
// If one or more sync committee signatures fail validation the node MUST return a 400 error with
// details of which sync committee signatures have failed, and why.
//
// POST /eth/v1/beacon/pool/sync_committees
func (s *Server) handleSubmitPoolSyncCommitteeSignaturesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolSyncCommitteeSignatures"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/sync_committees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolSyncCommitteeSignatures",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolSyncCommitteeSignatures",
			ID:   "submitPoolSyncCommitteeSignatures",
		}
	)
	request, close, err := s.decodeSubmitPoolSyncCommitteeSignaturesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolSyncCommitteeSignaturesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolSyncCommitteeSignatures",
			OperationSummary: "Submit sync committee signatures to node",
			OperationID:      "submitPoolSyncCommitteeSignatures",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []SubmitPoolSyncCommitteeSignaturesReqItem
			Params   = struct{}
			Response = SubmitPoolSyncCommitteeSignaturesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolSyncCommitteeSignatures(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolSyncCommitteeSignatures(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolSyncCommitteeSignaturesResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitPoolVoluntaryExitRequest handles submitPoolVoluntaryExit operation.
//
// Submits SignedVoluntaryExit object to node's pool and if passes validation node MUST broadcast it
// to network.
//
// POST /eth/v1/beacon/pool/voluntary_exits
func (s *Server) handleSubmitPoolVoluntaryExitRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitPoolVoluntaryExit"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/beacon/pool/voluntary_exits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitPoolVoluntaryExit",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitPoolVoluntaryExit",
			ID:   "submitPoolVoluntaryExit",
		}
	)
	request, close, err := s.decodeSubmitPoolVoluntaryExitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitPoolVoluntaryExitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitPoolVoluntaryExit",
			OperationSummary: "Submit SignedVoluntaryExit object to node's pool",
			OperationID:      "submitPoolVoluntaryExit",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *SubmitPoolVoluntaryExitReq
			Params   = struct{}
			Response = SubmitPoolVoluntaryExitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitPoolVoluntaryExit(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitPoolVoluntaryExit(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitPoolVoluntaryExitResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitSyncCommitteeSelectionsRequest handles submitSyncCommitteeSelections operation.
//
// Submit sync committee selections to a DVT middleware client. It returns the threshold aggregated
// sync
// committee selection. This endpoint should be used by a validator client running as part of a
// distributed
// validator cluster, and is implemented by a distributed validator middleware client. This endpoint
// is
// used to exchange partial selection proofs (slot signatures) for combined/aggregated selection
// proofs to
// allow a validator client to correctly determine if any of its validators has been selected to
// perform a
// sync committee contribution (sync aggregation) duty in a slot. Validator clients running in a
// distributed validator cluster must query this endpoint
// at the start of each slot for all validators that are included in the current sync committee.
// Consensus
// clients need not support this endpoint and may return a 501.
//
// POST /eth/v1/validator/sync_committee_selections
func (s *Server) handleSubmitSyncCommitteeSelectionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitSyncCommitteeSelections"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/eth/v1/validator/sync_committee_selections"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SubmitSyncCommitteeSelections",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitSyncCommitteeSelections",
			ID:   "submitSyncCommitteeSelections",
		}
	)
	request, close, err := s.decodeSubmitSyncCommitteeSelectionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitSyncCommitteeSelectionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitSyncCommitteeSelections",
			OperationSummary: "Determine if a distributed validator has been selected to make a sync committee contribution",
			OperationID:      "submitSyncCommitteeSelections",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = []SubmitSyncCommitteeSelectionsReqItem
			Params   = struct{}
			Response = SubmitSyncCommitteeSelectionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitSyncCommitteeSelections(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitSyncCommitteeSelections(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitSyncCommitteeSelectionsResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
