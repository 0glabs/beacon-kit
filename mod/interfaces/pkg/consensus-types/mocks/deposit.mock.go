// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	bytes "github.com/berachain/beacon-kit/mod/primitives/pkg/bytes"
	math "github.com/berachain/beacon-kit/mod/primitives/pkg/math"

	mock "github.com/stretchr/testify/mock"
)

// Deposit is an autogenerated mock type for the Deposit type
type Deposit[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	mock.Mock
}

type Deposit_Expecter[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	mock *mock.Mock
}

func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) EXPECT() *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]{mock: &_m.Mock}
}

// GetAmount provides a mock function with given fields:
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) GetAmount() math.U64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAmount")
	}

	var r0 math.U64
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	return r0
}

// Deposit_GetAmount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAmount'
type Deposit_GetAmount_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// GetAmount is a helper method to define mock.On call
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) GetAmount() *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("GetAmount")}
}

func (_c *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func()) *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 math.U64) *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func() math.U64) *Deposit_GetAmount_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// GetIndex provides a mock function with given fields:
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) GetIndex() uint64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetIndex")
	}

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// Deposit_GetIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndex'
type Deposit_GetIndex_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// GetIndex is a helper method to define mock.On call
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) GetIndex() *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("GetIndex")}
}

func (_c *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func()) *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 uint64) *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func() uint64) *Deposit_GetIndex_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// GetPubkey provides a mock function with given fields:
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) GetPubkey() bytes.B48 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPubkey")
	}

	var r0 bytes.B48
	if rf, ok := ret.Get(0).(func() bytes.B48); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B48)
		}
	}

	return r0
}

// Deposit_GetPubkey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPubkey'
type Deposit_GetPubkey_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// GetPubkey is a helper method to define mock.On call
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) GetPubkey() *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("GetPubkey")}
}

func (_c *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func()) *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 bytes.B48) *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func() bytes.B48) *Deposit_GetPubkey_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// GetSignature provides a mock function with given fields:
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) GetSignature() bytes.B96 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSignature")
	}

	var r0 bytes.B96
	if rf, ok := ret.Get(0).(func() bytes.B96); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B96)
		}
	}

	return r0
}

// Deposit_GetSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignature'
type Deposit_GetSignature_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// GetSignature is a helper method to define mock.On call
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) GetSignature() *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("GetSignature")}
}

func (_c *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func()) *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 bytes.B96) *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func() bytes.B96) *Deposit_GetSignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// GetWithdrawalCredentials provides a mock function with given fields:
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) GetWithdrawalCredentials() WithdrawalCredentialsT {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetWithdrawalCredentials")
	}

	var r0 WithdrawalCredentialsT
	if rf, ok := ret.Get(0).(func() WithdrawalCredentialsT); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(WithdrawalCredentialsT)
	}

	return r0
}

// Deposit_GetWithdrawalCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWithdrawalCredentials'
type Deposit_GetWithdrawalCredentials_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// GetWithdrawalCredentials is a helper method to define mock.On call
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) GetWithdrawalCredentials() *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("GetWithdrawalCredentials")}
}

func (_c *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func()) *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 WithdrawalCredentialsT) *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func() WithdrawalCredentialsT) *Deposit_GetWithdrawalCredentials_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// New provides a mock function with given fields: pubkey, credentials, amount, signature, index
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) New(pubkey bytes.B48, credentials WithdrawalCredentialsT, amount math.U64, signature bytes.B96, index uint64) T {
	ret := _m.Called(pubkey, credentials, amount, signature, index)

	if len(ret) == 0 {
		panic("no return value specified for New")
	}

	var r0 T
	if rf, ok := ret.Get(0).(func(bytes.B48, WithdrawalCredentialsT, math.U64, bytes.B96, uint64) T); ok {
		r0 = rf(pubkey, credentials, amount, signature, index)
	} else {
		r0 = ret.Get(0).(T)
	}

	return r0
}

// Deposit_New_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'New'
type Deposit_New_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// New is a helper method to define mock.On call
//   - pubkey bytes.B48
//   - credentials WithdrawalCredentialsT
//   - amount math.U64
//   - signature bytes.B96
//   - index uint64
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) New(pubkey interface{}, credentials interface{}, amount interface{}, signature interface{}, index interface{}) *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("New", pubkey, credentials, amount, signature, index)}
}

func (_c *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func(pubkey bytes.B48, credentials WithdrawalCredentialsT, amount math.U64, signature bytes.B96, index uint64)) *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bytes.B48), args[1].(WithdrawalCredentialsT), args[2].(math.U64), args[3].(bytes.B96), args[4].(uint64))
	})
	return _c
}

func (_c *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 T) *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func(bytes.B48, WithdrawalCredentialsT, math.U64, bytes.B96, uint64) T) *Deposit_New_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// VerifySignature provides a mock function with given fields: forkData, domainType, signatureVerificationFn
func (_m *Deposit[T, ForkDataT, WithdrawalCredentialsT]) VerifySignature(forkData ForkDataT, domainType bytes.B4, signatureVerificationFn func(bytes.B48, []byte, bytes.B96) error) error {
	ret := _m.Called(forkData, domainType, signatureVerificationFn)

	if len(ret) == 0 {
		panic("no return value specified for VerifySignature")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ForkDataT, bytes.B4, func(bytes.B48, []byte, bytes.B96) error) error); ok {
		r0 = rf(forkData, domainType, signatureVerificationFn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Deposit_VerifySignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifySignature'
type Deposit_VerifySignature_Call[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}] struct {
	*mock.Call
}

// VerifySignature is a helper method to define mock.On call
//   - forkData ForkDataT
//   - domainType bytes.B4
//   - signatureVerificationFn func(bytes.B48 , []byte , bytes.B96) error
func (_e *Deposit_Expecter[T, ForkDataT, WithdrawalCredentialsT]) VerifySignature(forkData interface{}, domainType interface{}, signatureVerificationFn interface{}) *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	return &Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT]{Call: _e.mock.On("VerifySignature", forkData, domainType, signatureVerificationFn)}
}

func (_c *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT]) Run(run func(forkData ForkDataT, domainType bytes.B4, signatureVerificationFn func(bytes.B48, []byte, bytes.B96) error)) *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ForkDataT), args[1].(bytes.B4), args[2].(func(bytes.B48, []byte, bytes.B96) error))
	})
	return _c
}

func (_c *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT]) Return(_a0 error) *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT]) RunAndReturn(run func(ForkDataT, bytes.B4, func(bytes.B48, []byte, bytes.B96) error) error) *Deposit_VerifySignature_Call[T, ForkDataT, WithdrawalCredentialsT] {
	_c.Call.Return(run)
	return _c
}

// NewDeposit creates a new instance of Deposit. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDeposit[T interface{}, ForkDataT interface{}, WithdrawalCredentialsT interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *Deposit[T, ForkDataT, WithdrawalCredentialsT] {
	mock := &Deposit[T, ForkDataT, WithdrawalCredentialsT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
