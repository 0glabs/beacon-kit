// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	constraints "github.com/berachain/beacon-kit/mod/primitives/pkg/constraints"

	mock "github.com/stretchr/testify/mock"

	transition "github.com/berachain/beacon-kit/mod/primitives/pkg/transition"

	types "github.com/berachain/beacon-kit/mod/interfaces/pkg/consensus-types"
)

// BlockchainService is an autogenerated mock type for the BlockchainService type
type BlockchainService[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	mock.Mock
}

type BlockchainService_Expecter[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	mock *mock.Mock
}

func (_m *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) EXPECT() *BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	return &BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{mock: &_m.Mock}
}

// ProcessBeaconBlock provides a mock function with given fields: _a0, _a1
func (_m *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ProcessBeaconBlock(_a0 context.Context, _a1 BeaconBlockT) (transition.ValidatorUpdates, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ProcessBeaconBlock")
	}

	var r0 transition.ValidatorUpdates
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, BeaconBlockT) (transition.ValidatorUpdates, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, BeaconBlockT) transition.ValidatorUpdates); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(transition.ValidatorUpdates)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, BeaconBlockT) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockchainService_ProcessBeaconBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessBeaconBlock'
type BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	*mock.Call
}

// ProcessBeaconBlock is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 BeaconBlockT
func (_e *BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ProcessBeaconBlock(_a0 interface{}, _a1 interface{}) *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	return &BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{Call: _e.mock.On("ProcessBeaconBlock", _a0, _a1)}
}

func (_c *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Run(run func(_a0 context.Context, _a1 BeaconBlockT)) *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(BeaconBlockT))
	})
	return _c
}

func (_c *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Return(_a0 transition.ValidatorUpdates, _a1 error) *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) RunAndReturn(run func(context.Context, BeaconBlockT) (transition.ValidatorUpdates, error)) *BlockchainService_ProcessBeaconBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(run)
	return _c
}

// ProcessGenesisData provides a mock function with given fields: _a0, _a1
func (_m *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ProcessGenesisData(_a0 context.Context, _a1 GenesisT) (transition.ValidatorUpdates, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ProcessGenesisData")
	}

	var r0 transition.ValidatorUpdates
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, GenesisT) (transition.ValidatorUpdates, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, GenesisT) transition.ValidatorUpdates); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(transition.ValidatorUpdates)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, GenesisT) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockchainService_ProcessGenesisData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessGenesisData'
type BlockchainService_ProcessGenesisData_Call[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	*mock.Call
}

// ProcessGenesisData is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 GenesisT
func (_e *BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ProcessGenesisData(_a0 interface{}, _a1 interface{}) *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	return &BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{Call: _e.mock.On("ProcessGenesisData", _a0, _a1)}
}

func (_c *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Run(run func(_a0 context.Context, _a1 GenesisT)) *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(GenesisT))
	})
	return _c
}

func (_c *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Return(_a0 transition.ValidatorUpdates, _a1 error) *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) RunAndReturn(run func(context.Context, GenesisT) (transition.ValidatorUpdates, error)) *BlockchainService_ProcessGenesisData_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(run)
	return _c
}

// ReceiveBlock provides a mock function with given fields: ctx, blk
func (_m *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ReceiveBlock(ctx context.Context, blk BeaconBlockT) error {
	ret := _m.Called(ctx, blk)

	if len(ret) == 0 {
		panic("no return value specified for ReceiveBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, BeaconBlockT) error); ok {
		r0 = rf(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BlockchainService_ReceiveBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReceiveBlock'
type BlockchainService_ReceiveBlock_Call[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	*mock.Call
}

// ReceiveBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - blk BeaconBlockT
func (_e *BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) ReceiveBlock(ctx interface{}, blk interface{}) *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	return &BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{Call: _e.mock.On("ReceiveBlock", ctx, blk)}
}

func (_c *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Run(run func(ctx context.Context, blk BeaconBlockT)) *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(BeaconBlockT))
	})
	return _c
}

func (_c *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Return(_a0 error) *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) RunAndReturn(run func(context.Context, BeaconBlockT) error) *BlockchainService_ReceiveBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(run)
	return _c
}

// VerifyIncomingBlock provides a mock function with given fields: ctx, blk
func (_m *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) VerifyIncomingBlock(ctx context.Context, blk BeaconBlockT) error {
	ret := _m.Called(ctx, blk)

	if len(ret) == 0 {
		panic("no return value specified for VerifyIncomingBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, BeaconBlockT) error); ok {
		r0 = rf(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BlockchainService_VerifyIncomingBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyIncomingBlock'
type BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]] struct {
	*mock.Call
}

// VerifyIncomingBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - blk BeaconBlockT
func (_e *BlockchainService_Expecter[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) VerifyIncomingBlock(ctx interface{}, blk interface{}) *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	return &BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{Call: _e.mock.On("VerifyIncomingBlock", ctx, blk)}
}

func (_c *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Run(run func(ctx context.Context, blk BeaconBlockT)) *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(BeaconBlockT))
	})
	return _c
}

func (_c *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) Return(_a0 error) *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]) RunAndReturn(run func(context.Context, BeaconBlockT) error) *BlockchainService_VerifyIncomingBlock_Call[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	_c.Call.Return(run)
	return _c
}

// NewBlockchainService creates a new instance of BlockchainService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockchainService[BeaconBlockT interface{}, BlobSidecarsT constraints.SSZMarshallable, DepositT interface{}, ExecutionPayloadHeaderT types.ExecutionPayloadHeader[ExecutionPayloadHeaderT], GenesisT types.Genesis[DepositT, ExecutionPayloadHeaderT]](t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT] {
	mock := &BlockchainService[BeaconBlockT, BlobSidecarsT, DepositT, ExecutionPayloadHeaderT, GenesisT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
