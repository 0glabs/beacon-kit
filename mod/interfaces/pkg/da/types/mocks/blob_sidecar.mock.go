// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	bytes "github.com/berachain/beacon-kit/mod/primitives/pkg/bytes"
	eip4844 "github.com/berachain/beacon-kit/mod/primitives/pkg/eip4844"

	math "github.com/berachain/beacon-kit/mod/primitives/pkg/math"

	mock "github.com/stretchr/testify/mock"
)

// BlobSidecar is an autogenerated mock type for the BlobSidecar type
type BlobSidecar[T interface{}, BeaconBlockHeaderT interface{}] struct {
	mock.Mock
}

type BlobSidecar_Expecter[T interface{}, BeaconBlockHeaderT interface{}] struct {
	mock *mock.Mock
}

func (_m *BlobSidecar[T, BeaconBlockHeaderT]) EXPECT() *BlobSidecar_Expecter[T, BeaconBlockHeaderT] {
	return &BlobSidecar_Expecter[T, BeaconBlockHeaderT]{mock: &_m.Mock}
}

// GetBlob provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) GetBlob() *eip4844.Blob {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBlob")
	}

	var r0 *eip4844.Blob
	if rf, ok := ret.Get(0).(func() *eip4844.Blob); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eip4844.Blob)
		}
	}

	return r0
}

// BlobSidecar_GetBlob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlob'
type BlobSidecar_GetBlob_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// GetBlob is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) GetBlob() *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("GetBlob")}
}

func (_c *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT]) Return(_a0 *eip4844.Blob) *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() *eip4844.Blob) *BlobSidecar_GetBlob_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// GetCommitment provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) GetCommitment() eip4844.KZGCommitment {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCommitment")
	}

	var r0 eip4844.KZGCommitment
	if rf, ok := ret.Get(0).(func() eip4844.KZGCommitment); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(eip4844.KZGCommitment)
		}
	}

	return r0
}

// BlobSidecar_GetCommitment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitment'
type BlobSidecar_GetCommitment_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// GetCommitment is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) GetCommitment() *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("GetCommitment")}
}

func (_c *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT]) Return(_a0 eip4844.KZGCommitment) *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() eip4844.KZGCommitment) *BlobSidecar_GetCommitment_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// GetProof provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) GetProof() bytes.B48 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetProof")
	}

	var r0 bytes.B48
	if rf, ok := ret.Get(0).(func() bytes.B48); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B48)
		}
	}

	return r0
}

// BlobSidecar_GetProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProof'
type BlobSidecar_GetProof_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// GetProof is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) GetProof() *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("GetProof")}
}

func (_c *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT]) Return(_a0 bytes.B48) *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() bytes.B48) *BlobSidecar_GetProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// GetSlot provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) GetSlot() math.U64 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSlot")
	}

	var r0 math.U64
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	return r0
}

// BlobSidecar_GetSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlot'
type BlobSidecar_GetSlot_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// GetSlot is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) GetSlot() *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("GetSlot")}
}

func (_c *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT]) Return(_a0 math.U64) *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() math.U64) *BlobSidecar_GetSlot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// HasValidInclusionProof provides a mock function with given fields: kzgOffset
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) HasValidInclusionProof(kzgOffset uint64) bool {
	ret := _m.Called(kzgOffset)

	if len(ret) == 0 {
		panic("no return value specified for HasValidInclusionProof")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(kzgOffset)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlobSidecar_HasValidInclusionProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasValidInclusionProof'
type BlobSidecar_HasValidInclusionProof_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// HasValidInclusionProof is a helper method to define mock.On call
//   - kzgOffset uint64
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) HasValidInclusionProof(kzgOffset interface{}) *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("HasValidInclusionProof", kzgOffset)}
}

func (_c *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT]) Run(run func(kzgOffset uint64)) *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT]) Return(_a0 bool) *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func(uint64) bool) *BlobSidecar_HasValidInclusionProof_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// HashTreeRoot provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) HashTreeRoot() ([32]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for HashTreeRoot")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([32]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() [32]byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlobSidecar_HashTreeRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashTreeRoot'
type BlobSidecar_HashTreeRoot_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// HashTreeRoot is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) HashTreeRoot() *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("HashTreeRoot")}
}

func (_c *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT]) Return(_a0 [32]byte, _a1 error) *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() ([32]byte, error)) *BlobSidecar_HashTreeRoot_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// IsNil provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) IsNil() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsNil")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlobSidecar_IsNil_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNil'
type BlobSidecar_IsNil_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// IsNil is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) IsNil() *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("IsNil")}
}

func (_c *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT]) Return(_a0 bool) *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() bool) *BlobSidecar_IsNil_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// MarshalSSZ provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) MarshalSSZ() ([]byte, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MarshalSSZ")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]byte, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlobSidecar_MarshalSSZ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalSSZ'
type BlobSidecar_MarshalSSZ_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// MarshalSSZ is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) MarshalSSZ() *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("MarshalSSZ")}
}

func (_c *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT]) Return(_a0 []byte, _a1 error) *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() ([]byte, error)) *BlobSidecar_MarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// MarshalSSZTo provides a mock function with given fields: _a0
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) MarshalSSZTo(_a0 []byte) ([]byte, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for MarshalSSZTo")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) ([]byte, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlobSidecar_MarshalSSZTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalSSZTo'
type BlobSidecar_MarshalSSZTo_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// MarshalSSZTo is a helper method to define mock.On call
//   - _a0 []byte
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) MarshalSSZTo(_a0 interface{}) *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("MarshalSSZTo", _a0)}
}

func (_c *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT]) Run(run func(_a0 []byte)) *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT]) Return(_a0 []byte, _a1 error) *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func([]byte) ([]byte, error)) *BlobSidecar_MarshalSSZTo_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// New provides a mock function with given fields: index, header, blob, commitment, proof, inclusionProof
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) New(index math.U64, header BeaconBlockHeaderT, blob *eip4844.Blob, commitment eip4844.KZGCommitment, proof bytes.B48, inclusionProof [][32]byte) T {
	ret := _m.Called(index, header, blob, commitment, proof, inclusionProof)

	if len(ret) == 0 {
		panic("no return value specified for New")
	}

	var r0 T
	if rf, ok := ret.Get(0).(func(math.U64, BeaconBlockHeaderT, *eip4844.Blob, eip4844.KZGCommitment, bytes.B48, [][32]byte) T); ok {
		r0 = rf(index, header, blob, commitment, proof, inclusionProof)
	} else {
		r0 = ret.Get(0).(T)
	}

	return r0
}

// BlobSidecar_New_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'New'
type BlobSidecar_New_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// New is a helper method to define mock.On call
//   - index math.U64
//   - header BeaconBlockHeaderT
//   - blob *eip4844.Blob
//   - commitment eip4844.KZGCommitment
//   - proof bytes.B48
//   - inclusionProof [][32]byte
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) New(index interface{}, header interface{}, blob interface{}, commitment interface{}, proof interface{}, inclusionProof interface{}) *BlobSidecar_New_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_New_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("New", index, header, blob, commitment, proof, inclusionProof)}
}

func (_c *BlobSidecar_New_Call[T, BeaconBlockHeaderT]) Run(run func(index math.U64, header BeaconBlockHeaderT, blob *eip4844.Blob, commitment eip4844.KZGCommitment, proof bytes.B48, inclusionProof [][32]byte)) *BlobSidecar_New_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64), args[1].(BeaconBlockHeaderT), args[2].(*eip4844.Blob), args[3].(eip4844.KZGCommitment), args[4].(bytes.B48), args[5].([][32]byte))
	})
	return _c
}

func (_c *BlobSidecar_New_Call[T, BeaconBlockHeaderT]) Return(_a0 T) *BlobSidecar_New_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_New_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func(math.U64, BeaconBlockHeaderT, *eip4844.Blob, eip4844.KZGCommitment, bytes.B48, [][32]byte) T) *BlobSidecar_New_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// SizeSSZ provides a mock function with given fields:
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) SizeSSZ() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SizeSSZ")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// BlobSidecar_SizeSSZ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SizeSSZ'
type BlobSidecar_SizeSSZ_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// SizeSSZ is a helper method to define mock.On call
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) SizeSSZ() *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("SizeSSZ")}
}

func (_c *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT]) Run(run func()) *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT]) Return(_a0 int) *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func() int) *BlobSidecar_SizeSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// UnmarshalSSZ provides a mock function with given fields: _a0
func (_m *BlobSidecar[T, BeaconBlockHeaderT]) UnmarshalSSZ(_a0 []byte) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalSSZ")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BlobSidecar_UnmarshalSSZ_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmarshalSSZ'
type BlobSidecar_UnmarshalSSZ_Call[T interface{}, BeaconBlockHeaderT interface{}] struct {
	*mock.Call
}

// UnmarshalSSZ is a helper method to define mock.On call
//   - _a0 []byte
func (_e *BlobSidecar_Expecter[T, BeaconBlockHeaderT]) UnmarshalSSZ(_a0 interface{}) *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT] {
	return &BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT]{Call: _e.mock.On("UnmarshalSSZ", _a0)}
}

func (_c *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT]) Run(run func(_a0 []byte)) *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT]) Return(_a0 error) *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT]) RunAndReturn(run func([]byte) error) *BlobSidecar_UnmarshalSSZ_Call[T, BeaconBlockHeaderT] {
	_c.Call.Return(run)
	return _c
}

// NewBlobSidecar creates a new instance of BlobSidecar. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlobSidecar[T interface{}, BeaconBlockHeaderT interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *BlobSidecar[T, BeaconBlockHeaderT] {
	mock := &BlobSidecar[T, BeaconBlockHeaderT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
