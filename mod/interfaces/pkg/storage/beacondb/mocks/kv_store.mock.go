// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	context "context"

	bytes "github.com/berachain/beacon-kit/mod/primitives/pkg/bytes"

	math "github.com/berachain/beacon-kit/mod/primitives/pkg/math"

	mock "github.com/stretchr/testify/mock"
)

// KVStore is an autogenerated mock type for the KVStore type
type KVStore[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	mock.Mock
}

type KVStore_Expecter[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	mock *mock.Mock
}

func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) EXPECT() *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{mock: &_m.Mock}
}

// AddValidator provides a mock function with given fields: val
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidator(val ValidatorT) error {
	ret := _m.Called(val)

	if len(ret) == 0 {
		panic("no return value specified for AddValidator")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ValidatorT) error); ok {
		r0 = rf(val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_AddValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddValidator'
type KVStore_AddValidator_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// AddValidator is a helper method to define mock.On call
//   - val ValidatorT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidator(val interface{}) *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("AddValidator", val)}
}

func (_c *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(val ValidatorT)) *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ValidatorT))
	})
	return _c
}

func (_c *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ValidatorT) error) *KVStore_AddValidator_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// AddValidatorBartio provides a mock function with given fields: val
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidatorBartio(val ValidatorT) error {
	ret := _m.Called(val)

	if len(ret) == 0 {
		panic("no return value specified for AddValidatorBartio")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ValidatorT) error); ok {
		r0 = rf(val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_AddValidatorBartio_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddValidatorBartio'
type KVStore_AddValidatorBartio_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// AddValidatorBartio is a helper method to define mock.On call
//   - val ValidatorT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) AddValidatorBartio(val interface{}) *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("AddValidatorBartio", val)}
}

func (_c *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(val ValidatorT)) *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ValidatorT))
	})
	return _c
}

func (_c *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ValidatorT) error) *KVStore_AddValidatorBartio_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// Context provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Context() context.Context {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Context")
	}

	var r0 context.Context
	if rf, ok := ret.Get(0).(func() context.Context); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	return r0
}

// KVStore_Context_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Context'
type KVStore_Context_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// Context is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Context() *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("Context")}
}

func (_c *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 context.Context) *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() context.Context) *KVStore_Context_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// Copy provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Copy() T {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 T
	if rf, ok := ret.Get(0).(func() T); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(T)
	}

	return r0
}

// KVStore_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type KVStore_Copy_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Copy() *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("Copy")}
}

func (_c *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 T) *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() T) *KVStore_Copy_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetBalance provides a mock function with given fields: idx
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBalance(idx math.U64) (math.U64, error) {
	ret := _m.Called(idx)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64) (math.U64, error)); ok {
		return rf(idx)
	}
	if rf, ok := ret.Get(0).(func(math.U64) math.U64); ok {
		r0 = rf(idx)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(math.U64) error); ok {
		r1 = rf(idx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalance'
type KVStore_GetBalance_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetBalance is a helper method to define mock.On call
//   - idx math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBalance(idx interface{}) *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetBalance", idx)}
}

func (_c *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(idx math.U64)) *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) (math.U64, error)) *KVStore_GetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetBalances provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBalances() ([]uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBalances")
	}

	var r0 []uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []uint64); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalances'
type KVStore_GetBalances_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetBalances is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBalances() *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetBalances")}
}

func (_c *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 []uint64, _a1 error) *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() ([]uint64, error)) *KVStore_GetBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetBlockRootAtIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBlockRootAtIndex(index uint64) (bytes.B32, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockRootAtIndex")
	}

	var r0 bytes.B32
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (bytes.B32, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(uint64) bytes.B32); ok {
		r0 = rf(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B32)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetBlockRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockRootAtIndex'
type KVStore_GetBlockRootAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetBlockRootAtIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetBlockRootAtIndex(index interface{}) *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetBlockRootAtIndex", index)}
}

func (_c *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 bytes.B32, _a1 error) *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) (bytes.B32, error)) *KVStore_GetBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetEth1Data provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetEth1Data() (Eth1DataT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEth1Data")
	}

	var r0 Eth1DataT
	var r1 error
	if rf, ok := ret.Get(0).(func() (Eth1DataT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() Eth1DataT); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(Eth1DataT)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetEth1Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEth1Data'
type KVStore_GetEth1Data_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetEth1Data is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetEth1Data() *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetEth1Data")}
}

func (_c *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 Eth1DataT, _a1 error) *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (Eth1DataT, error)) *KVStore_GetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetEth1DepositIndex provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetEth1DepositIndex() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEth1DepositIndex")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetEth1DepositIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEth1DepositIndex'
type KVStore_GetEth1DepositIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetEth1DepositIndex is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetEth1DepositIndex() *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetEth1DepositIndex")}
}

func (_c *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 uint64, _a1 error) *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (uint64, error)) *KVStore_GetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetFork provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetFork() (ForkT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetFork")
	}

	var r0 ForkT
	var r1 error
	if rf, ok := ret.Get(0).(func() (ForkT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ForkT); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ForkT)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetFork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFork'
type KVStore_GetFork_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetFork is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetFork() *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetFork")}
}

func (_c *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 ForkT, _a1 error) *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (ForkT, error)) *KVStore_GetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetGenesisValidatorsRoot provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetGenesisValidatorsRoot() (bytes.B32, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetGenesisValidatorsRoot")
	}

	var r0 bytes.B32
	var r1 error
	if rf, ok := ret.Get(0).(func() (bytes.B32, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bytes.B32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B32)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetGenesisValidatorsRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGenesisValidatorsRoot'
type KVStore_GetGenesisValidatorsRoot_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetGenesisValidatorsRoot is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetGenesisValidatorsRoot() *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetGenesisValidatorsRoot")}
}

func (_c *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 bytes.B32, _a1 error) *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (bytes.B32, error)) *KVStore_GetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetLatestBlockHeader provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetLatestBlockHeader() (BeaconBlockHeaderT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLatestBlockHeader")
	}

	var r0 BeaconBlockHeaderT
	var r1 error
	if rf, ok := ret.Get(0).(func() (BeaconBlockHeaderT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() BeaconBlockHeaderT); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(BeaconBlockHeaderT)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetLatestBlockHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestBlockHeader'
type KVStore_GetLatestBlockHeader_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetLatestBlockHeader is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetLatestBlockHeader() *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetLatestBlockHeader")}
}

func (_c *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 BeaconBlockHeaderT, _a1 error) *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (BeaconBlockHeaderT, error)) *KVStore_GetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetLatestExecutionPayloadHeader provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetLatestExecutionPayloadHeader() (ExecutionPayloadHeaderT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLatestExecutionPayloadHeader")
	}

	var r0 ExecutionPayloadHeaderT
	var r1 error
	if rf, ok := ret.Get(0).(func() (ExecutionPayloadHeaderT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ExecutionPayloadHeaderT); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ExecutionPayloadHeaderT)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetLatestExecutionPayloadHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestExecutionPayloadHeader'
type KVStore_GetLatestExecutionPayloadHeader_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetLatestExecutionPayloadHeader is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetLatestExecutionPayloadHeader() *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetLatestExecutionPayloadHeader")}
}

func (_c *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 ExecutionPayloadHeaderT, _a1 error) *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (ExecutionPayloadHeaderT, error)) *KVStore_GetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetNextWithdrawalIndex provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetNextWithdrawalIndex() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetNextWithdrawalIndex")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetNextWithdrawalIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextWithdrawalIndex'
type KVStore_GetNextWithdrawalIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetNextWithdrawalIndex is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetNextWithdrawalIndex() *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetNextWithdrawalIndex")}
}

func (_c *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 uint64, _a1 error) *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (uint64, error)) *KVStore_GetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetNextWithdrawalValidatorIndex provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetNextWithdrawalValidatorIndex() (math.U64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetNextWithdrawalValidatorIndex")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func() (math.U64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetNextWithdrawalValidatorIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextWithdrawalValidatorIndex'
type KVStore_GetNextWithdrawalValidatorIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetNextWithdrawalValidatorIndex is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetNextWithdrawalValidatorIndex() *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetNextWithdrawalValidatorIndex")}
}

func (_c *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (math.U64, error)) *KVStore_GetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetRandaoMixAtIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetRandaoMixAtIndex(index uint64) (bytes.B32, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for GetRandaoMixAtIndex")
	}

	var r0 bytes.B32
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (bytes.B32, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(uint64) bytes.B32); ok {
		r0 = rf(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B32)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetRandaoMixAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRandaoMixAtIndex'
type KVStore_GetRandaoMixAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetRandaoMixAtIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetRandaoMixAtIndex(index interface{}) *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetRandaoMixAtIndex", index)}
}

func (_c *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 bytes.B32, _a1 error) *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) (bytes.B32, error)) *KVStore_GetRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetSlashingAtIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlashingAtIndex(index uint64) (math.U64, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for GetSlashingAtIndex")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (math.U64, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(uint64) math.U64); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetSlashingAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlashingAtIndex'
type KVStore_GetSlashingAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetSlashingAtIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlashingAtIndex(index interface{}) *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetSlashingAtIndex", index)}
}

func (_c *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) (math.U64, error)) *KVStore_GetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetSlashings provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlashings() ([]uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSlashings")
	}

	var r0 []uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []uint64); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint64)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetSlashings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlashings'
type KVStore_GetSlashings_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetSlashings is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlashings() *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetSlashings")}
}

func (_c *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 []uint64, _a1 error) *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() ([]uint64, error)) *KVStore_GetSlashings_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetSlot provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlot() (math.U64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSlot")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func() (math.U64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlot'
type KVStore_GetSlot_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetSlot is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetSlot() *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetSlot")}
}

func (_c *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (math.U64, error)) *KVStore_GetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetTotalActiveBalances provides a mock function with given fields: _a0
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalActiveBalances(_a0 uint64) (math.U64, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for GetTotalActiveBalances")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (math.U64, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(uint64) math.U64); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetTotalActiveBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTotalActiveBalances'
type KVStore_GetTotalActiveBalances_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetTotalActiveBalances is a helper method to define mock.On call
//   - _a0 uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalActiveBalances(_a0 interface{}) *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetTotalActiveBalances", _a0)}
}

func (_c *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(_a0 uint64)) *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) (math.U64, error)) *KVStore_GetTotalActiveBalances_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetTotalSlashing provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalSlashing() (math.U64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTotalSlashing")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func() (math.U64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetTotalSlashing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTotalSlashing'
type KVStore_GetTotalSlashing_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetTotalSlashing is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalSlashing() *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetTotalSlashing")}
}

func (_c *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (math.U64, error)) *KVStore_GetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetTotalValidators provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalValidators() (uint64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTotalValidators")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func() (uint64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetTotalValidators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTotalValidators'
type KVStore_GetTotalValidators_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetTotalValidators is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetTotalValidators() *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetTotalValidators")}
}

func (_c *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 uint64, _a1 error) *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() (uint64, error)) *KVStore_GetTotalValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetValidators provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetValidators() ([]ValidatorT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetValidators")
	}

	var r0 []ValidatorT
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]ValidatorT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []ValidatorT); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ValidatorT)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetValidators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidators'
type KVStore_GetValidators_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetValidators is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetValidators() *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetValidators")}
}

func (_c *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 []ValidatorT, _a1 error) *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() ([]ValidatorT, error)) *KVStore_GetValidators_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// GetValidatorsByEffectiveBalance provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetValidatorsByEffectiveBalance() ([]ValidatorT, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorsByEffectiveBalance")
	}

	var r0 []ValidatorT
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]ValidatorT, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []ValidatorT); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ValidatorT)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_GetValidatorsByEffectiveBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidatorsByEffectiveBalance'
type KVStore_GetValidatorsByEffectiveBalance_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// GetValidatorsByEffectiveBalance is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) GetValidatorsByEffectiveBalance() *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("GetValidatorsByEffectiveBalance")}
}

func (_c *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 []ValidatorT, _a1 error) *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func() ([]ValidatorT, error)) *KVStore_GetValidatorsByEffectiveBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// RemoveValidatorAtIndex provides a mock function with given fields: idx
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RemoveValidatorAtIndex(idx math.U64) error {
	ret := _m.Called(idx)

	if len(ret) == 0 {
		panic("no return value specified for RemoveValidatorAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64) error); ok {
		r0 = rf(idx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_RemoveValidatorAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveValidatorAtIndex'
type KVStore_RemoveValidatorAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// RemoveValidatorAtIndex is a helper method to define mock.On call
//   - idx math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RemoveValidatorAtIndex(idx interface{}) *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("RemoveValidatorAtIndex", idx)}
}

func (_c *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(idx math.U64)) *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) error) *KVStore_RemoveValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields:
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Save() {
	_m.Called()
}

// KVStore_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type KVStore_Save_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Save() *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("Save")}
}

func (_c *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func()) *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return() *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return()
	return _c
}

func (_c *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func()) *KVStore_Save_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetBalance provides a mock function with given fields: idx, balance
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetBalance(idx math.U64, balance math.U64) error {
	ret := _m.Called(idx, balance)

	if len(ret) == 0 {
		panic("no return value specified for SetBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64, math.U64) error); ok {
		r0 = rf(idx, balance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetBalance'
type KVStore_SetBalance_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetBalance is a helper method to define mock.On call
//   - idx math.U64
//   - balance math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetBalance(idx interface{}, balance interface{}) *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetBalance", idx, balance)}
}

func (_c *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(idx math.U64, balance math.U64)) *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64), args[1].(math.U64))
	})
	return _c
}

func (_c *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64, math.U64) error) *KVStore_SetBalance_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetEth1Data provides a mock function with given fields: data
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1Data(data Eth1DataT) error {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for SetEth1Data")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(Eth1DataT) error); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetEth1Data_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEth1Data'
type KVStore_SetEth1Data_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetEth1Data is a helper method to define mock.On call
//   - data Eth1DataT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1Data(data interface{}) *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetEth1Data", data)}
}

func (_c *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(data Eth1DataT)) *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(Eth1DataT))
	})
	return _c
}

func (_c *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(Eth1DataT) error) *KVStore_SetEth1Data_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetEth1DepositIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1DepositIndex(index uint64) error {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for SetEth1DepositIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetEth1DepositIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEth1DepositIndex'
type KVStore_SetEth1DepositIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetEth1DepositIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetEth1DepositIndex(index interface{}) *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetEth1DepositIndex", index)}
}

func (_c *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) error) *KVStore_SetEth1DepositIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetFork provides a mock function with given fields: fork
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetFork(fork ForkT) error {
	ret := _m.Called(fork)

	if len(ret) == 0 {
		panic("no return value specified for SetFork")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ForkT) error); ok {
		r0 = rf(fork)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetFork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetFork'
type KVStore_SetFork_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetFork is a helper method to define mock.On call
//   - fork ForkT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetFork(fork interface{}) *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetFork", fork)}
}

func (_c *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(fork ForkT)) *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ForkT))
	})
	return _c
}

func (_c *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ForkT) error) *KVStore_SetFork_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetGenesisValidatorsRoot provides a mock function with given fields: root
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetGenesisValidatorsRoot(root bytes.B32) error {
	ret := _m.Called(root)

	if len(ret) == 0 {
		panic("no return value specified for SetGenesisValidatorsRoot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(bytes.B32) error); ok {
		r0 = rf(root)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetGenesisValidatorsRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGenesisValidatorsRoot'
type KVStore_SetGenesisValidatorsRoot_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetGenesisValidatorsRoot is a helper method to define mock.On call
//   - root bytes.B32
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetGenesisValidatorsRoot(root interface{}) *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetGenesisValidatorsRoot", root)}
}

func (_c *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(root bytes.B32)) *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bytes.B32))
	})
	return _c
}

func (_c *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(bytes.B32) error) *KVStore_SetGenesisValidatorsRoot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetLatestBlockHeader provides a mock function with given fields: header
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestBlockHeader(header BeaconBlockHeaderT) error {
	ret := _m.Called(header)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestBlockHeader")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(BeaconBlockHeaderT) error); ok {
		r0 = rf(header)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetLatestBlockHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLatestBlockHeader'
type KVStore_SetLatestBlockHeader_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetLatestBlockHeader is a helper method to define mock.On call
//   - header BeaconBlockHeaderT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestBlockHeader(header interface{}) *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetLatestBlockHeader", header)}
}

func (_c *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(header BeaconBlockHeaderT)) *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(BeaconBlockHeaderT))
	})
	return _c
}

func (_c *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(BeaconBlockHeaderT) error) *KVStore_SetLatestBlockHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetLatestExecutionPayloadHeader provides a mock function with given fields: payloadHeader
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestExecutionPayloadHeader(payloadHeader ExecutionPayloadHeaderT) error {
	ret := _m.Called(payloadHeader)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestExecutionPayloadHeader")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(ExecutionPayloadHeaderT) error); ok {
		r0 = rf(payloadHeader)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetLatestExecutionPayloadHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLatestExecutionPayloadHeader'
type KVStore_SetLatestExecutionPayloadHeader_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetLatestExecutionPayloadHeader is a helper method to define mock.On call
//   - payloadHeader ExecutionPayloadHeaderT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetLatestExecutionPayloadHeader(payloadHeader interface{}) *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetLatestExecutionPayloadHeader", payloadHeader)}
}

func (_c *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(payloadHeader ExecutionPayloadHeaderT)) *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(ExecutionPayloadHeaderT))
	})
	return _c
}

func (_c *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(ExecutionPayloadHeaderT) error) *KVStore_SetLatestExecutionPayloadHeader_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetNextWithdrawalIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalIndex(index uint64) error {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for SetNextWithdrawalIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetNextWithdrawalIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNextWithdrawalIndex'
type KVStore_SetNextWithdrawalIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetNextWithdrawalIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalIndex(index interface{}) *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetNextWithdrawalIndex", index)}
}

func (_c *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) error) *KVStore_SetNextWithdrawalIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetNextWithdrawalValidatorIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalValidatorIndex(index math.U64) error {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for SetNextWithdrawalValidatorIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64) error); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetNextWithdrawalValidatorIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNextWithdrawalValidatorIndex'
type KVStore_SetNextWithdrawalValidatorIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetNextWithdrawalValidatorIndex is a helper method to define mock.On call
//   - index math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetNextWithdrawalValidatorIndex(index interface{}) *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetNextWithdrawalValidatorIndex", index)}
}

func (_c *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index math.U64)) *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) error) *KVStore_SetNextWithdrawalValidatorIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetSlashingAtIndex provides a mock function with given fields: index, amount
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlashingAtIndex(index uint64, amount math.U64) error {
	ret := _m.Called(index, amount)

	if len(ret) == 0 {
		panic("no return value specified for SetSlashingAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, math.U64) error); ok {
		r0 = rf(index, amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetSlashingAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlashingAtIndex'
type KVStore_SetSlashingAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetSlashingAtIndex is a helper method to define mock.On call
//   - index uint64
//   - amount math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlashingAtIndex(index interface{}, amount interface{}) *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetSlashingAtIndex", index, amount)}
}

func (_c *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64, amount math.U64)) *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(math.U64))
	})
	return _c
}

func (_c *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, math.U64) error) *KVStore_SetSlashingAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetSlot provides a mock function with given fields: slot
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlot(slot math.U64) error {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for SetSlot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64) error); ok {
		r0 = rf(slot)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlot'
type KVStore_SetSlot_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetSlot is a helper method to define mock.On call
//   - slot math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetSlot(slot interface{}) *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetSlot", slot)}
}

func (_c *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(slot math.U64)) *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) error) *KVStore_SetSlot_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// SetTotalSlashing provides a mock function with given fields: total
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetTotalSlashing(total math.U64) error {
	ret := _m.Called(total)

	if len(ret) == 0 {
		panic("no return value specified for SetTotalSlashing")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64) error); ok {
		r0 = rf(total)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_SetTotalSlashing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTotalSlashing'
type KVStore_SetTotalSlashing_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// SetTotalSlashing is a helper method to define mock.On call
//   - total math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) SetTotalSlashing(total interface{}) *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("SetTotalSlashing", total)}
}

func (_c *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(total math.U64)) *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) error) *KVStore_SetTotalSlashing_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// StateRootAtIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) StateRootAtIndex(index uint64) (bytes.B32, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for StateRootAtIndex")
	}

	var r0 bytes.B32
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (bytes.B32, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(uint64) bytes.B32); ok {
		r0 = rf(index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B32)
		}
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_StateRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateRootAtIndex'
type KVStore_StateRootAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// StateRootAtIndex is a helper method to define mock.On call
//   - index uint64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) StateRootAtIndex(index interface{}) *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("StateRootAtIndex", index)}
}

func (_c *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64)) *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64))
	})
	return _c
}

func (_c *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 bytes.B32, _a1 error) *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64) (bytes.B32, error)) *KVStore_StateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateBlockRootAtIndex provides a mock function with given fields: index, root
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateBlockRootAtIndex(index uint64, root bytes.B32) error {
	ret := _m.Called(index, root)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBlockRootAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, bytes.B32) error); ok {
		r0 = rf(index, root)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_UpdateBlockRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBlockRootAtIndex'
type KVStore_UpdateBlockRootAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// UpdateBlockRootAtIndex is a helper method to define mock.On call
//   - index uint64
//   - root bytes.B32
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateBlockRootAtIndex(index interface{}, root interface{}) *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateBlockRootAtIndex", index, root)}
}

func (_c *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64, root bytes.B32)) *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bytes.B32))
	})
	return _c
}

func (_c *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, bytes.B32) error) *KVStore_UpdateBlockRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateRandaoMixAtIndex provides a mock function with given fields: index, mix
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateRandaoMixAtIndex(index uint64, mix bytes.B32) error {
	ret := _m.Called(index, mix)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRandaoMixAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, bytes.B32) error); ok {
		r0 = rf(index, mix)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_UpdateRandaoMixAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRandaoMixAtIndex'
type KVStore_UpdateRandaoMixAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// UpdateRandaoMixAtIndex is a helper method to define mock.On call
//   - index uint64
//   - mix bytes.B32
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateRandaoMixAtIndex(index interface{}, mix interface{}) *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateRandaoMixAtIndex", index, mix)}
}

func (_c *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64, mix bytes.B32)) *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bytes.B32))
	})
	return _c
}

func (_c *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, bytes.B32) error) *KVStore_UpdateRandaoMixAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateStateRootAtIndex provides a mock function with given fields: index, root
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateStateRootAtIndex(index uint64, root bytes.B32) error {
	ret := _m.Called(index, root)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStateRootAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, bytes.B32) error); ok {
		r0 = rf(index, root)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_UpdateStateRootAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStateRootAtIndex'
type KVStore_UpdateStateRootAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// UpdateStateRootAtIndex is a helper method to define mock.On call
//   - index uint64
//   - root bytes.B32
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateStateRootAtIndex(index interface{}, root interface{}) *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateStateRootAtIndex", index, root)}
}

func (_c *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index uint64, root bytes.B32)) *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint64), args[1].(bytes.B32))
	})
	return _c
}

func (_c *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(uint64, bytes.B32) error) *KVStore_UpdateStateRootAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// UpdateValidatorAtIndex provides a mock function with given fields: index, validator
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateValidatorAtIndex(index math.U64, validator ValidatorT) error {
	ret := _m.Called(index, validator)

	if len(ret) == 0 {
		panic("no return value specified for UpdateValidatorAtIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(math.U64, ValidatorT) error); ok {
		r0 = rf(index, validator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KVStore_UpdateValidatorAtIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateValidatorAtIndex'
type KVStore_UpdateValidatorAtIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// UpdateValidatorAtIndex is a helper method to define mock.On call
//   - index math.U64
//   - validator ValidatorT
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) UpdateValidatorAtIndex(index interface{}, validator interface{}) *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("UpdateValidatorAtIndex", index, validator)}
}

func (_c *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index math.U64, validator ValidatorT)) *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64), args[1].(ValidatorT))
	})
	return _c
}

func (_c *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 error) *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64, ValidatorT) error) *KVStore_UpdateValidatorAtIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// ValidatorByIndex provides a mock function with given fields: index
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorByIndex(index math.U64) (ValidatorT, error) {
	ret := _m.Called(index)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorByIndex")
	}

	var r0 ValidatorT
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64) (ValidatorT, error)); ok {
		return rf(index)
	}
	if rf, ok := ret.Get(0).(func(math.U64) ValidatorT); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Get(0).(ValidatorT)
	}

	if rf, ok := ret.Get(1).(func(math.U64) error); ok {
		r1 = rf(index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_ValidatorByIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatorByIndex'
type KVStore_ValidatorByIndex_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// ValidatorByIndex is a helper method to define mock.On call
//   - index math.U64
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorByIndex(index interface{}) *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("ValidatorByIndex", index)}
}

func (_c *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(index math.U64)) *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 ValidatorT, _a1 error) *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(math.U64) (ValidatorT, error)) *KVStore_ValidatorByIndex_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// ValidatorIndexByCometBFTAddress provides a mock function with given fields: cometBFTAddress
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorIndexByCometBFTAddress(cometBFTAddress []byte) (math.U64, error) {
	ret := _m.Called(cometBFTAddress)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorIndexByCometBFTAddress")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (math.U64, error)); ok {
		return rf(cometBFTAddress)
	}
	if rf, ok := ret.Get(0).(func([]byte) math.U64); ok {
		r0 = rf(cometBFTAddress)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(cometBFTAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_ValidatorIndexByCometBFTAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatorIndexByCometBFTAddress'
type KVStore_ValidatorIndexByCometBFTAddress_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// ValidatorIndexByCometBFTAddress is a helper method to define mock.On call
//   - cometBFTAddress []byte
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorIndexByCometBFTAddress(cometBFTAddress interface{}) *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("ValidatorIndexByCometBFTAddress", cometBFTAddress)}
}

func (_c *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(cometBFTAddress []byte)) *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func([]byte) (math.U64, error)) *KVStore_ValidatorIndexByCometBFTAddress_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// ValidatorIndexByPubkey provides a mock function with given fields: pubkey
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorIndexByPubkey(pubkey bytes.B48) (math.U64, error) {
	ret := _m.Called(pubkey)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorIndexByPubkey")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(bytes.B48) (math.U64, error)); ok {
		return rf(pubkey)
	}
	if rf, ok := ret.Get(0).(func(bytes.B48) math.U64); ok {
		r0 = rf(pubkey)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(bytes.B48) error); ok {
		r1 = rf(pubkey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KVStore_ValidatorIndexByPubkey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatorIndexByPubkey'
type KVStore_ValidatorIndexByPubkey_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// ValidatorIndexByPubkey is a helper method to define mock.On call
//   - pubkey bytes.B48
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) ValidatorIndexByPubkey(pubkey interface{}) *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("ValidatorIndexByPubkey", pubkey)}
}

func (_c *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(pubkey bytes.B48)) *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bytes.B48))
	})
	return _c
}

func (_c *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 math.U64, _a1 error) *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(bytes.B48) (math.U64, error)) *KVStore_ValidatorIndexByPubkey_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) WithContext(ctx context.Context) T {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 T
	if rf, ok := ret.Get(0).(func(context.Context) T); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(T)
	}

	return r0
}

// KVStore_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type KVStore_WithContext_Call[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}] struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KVStore_Expecter[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) WithContext(ctx interface{}) *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	return &KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Run(run func(ctx context.Context)) *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) Return(_a0 T) *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]) RunAndReturn(run func(context.Context) T) *KVStore_WithContext_Call[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	_c.Call.Return(run)
	return _c
}

// NewKVStore creates a new instance of KVStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKVStore[T interface{}, BeaconBlockHeaderT interface{}, Eth1DataT interface{}, ExecutionPayloadHeaderT interface{}, ForkT interface{}, ValidatorT interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT] {
	mock := &KVStore[T, BeaconBlockHeaderT, Eth1DataT, ExecutionPayloadHeaderT, ForkT, ValidatorT]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
